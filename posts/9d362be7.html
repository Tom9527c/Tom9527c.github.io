<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>TypeScript笔记（一） | Tom</title><meta name="keywords" content="前端,TypeScript,笔记,练习"><meta name="author" content="Tom"><meta name="copyright" content="Tom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="TypeScript笔记（一）"><meta name="application-name" content="TypeScript笔记（一）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="ffffff"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript笔记（一）"><meta property="og:url" content="https://tom9527c.github.io/posts/9d362be7.html"><meta property="og:site_name" content="Tom"><meta property="og:description" content="TypeScript的学习笔记和总结"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://mypic-ezp.pages.dev/img/img33.jpg"><meta property="article:author" content="Tom"><meta property="article:tag" content="代码,博客"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mypic-ezp.pages.dev/img/img33.jpg"><meta name="description" content="TypeScript的学习笔记和总结"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://tom9527c.github.io/posts/9d362be7"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/coffee.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/coffee.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/coffee.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/coffee.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/coffee.png"/><link rel="bookmark" href="/img/siteicon/coffee.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"👀跑哪里去了~","backTitle":"🐖抓到你啦～"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: {"appId":"IZ92U5VWUK","apiKey":"74b5762fa3c8aaafea1158754e1ca277","indexName":"aurora","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离上次更新已经","messageNext":"天了，文章内容可能已经过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Tom","link":"链接: ","source":"来源: Tom","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Tom',
  title: 'TypeScript笔记（一）',
  postAI: '',
  pageFillDescription: '1.TypeScript的环境搭, 一.什么是TypeScript, 二.环境配置, 1.全局编译TS文件, 2.配置 webpack 环境, 2.基础类型, 布尔类型 boolean, 数字类型 number, 字符串类型 string, 数组 array, 元组类型 Tuple, 3.枚举类型 enum, 任意值 any, 空值 void, Null 和 Undefined, Never, Symbol类型, BigInt类型, object对象类型, 3.类型推导(type inference), 一. 类型推导, 上下文类型, 二.包装对象, 三.联合类型（Union Types）, 可辨识联合（Discriminated Unions）, 四.类型断言, 五.字面量类型, 字符串字面量类型, 数字字面量类型, 类型别名, 接口 vs 类型别名, 赋值推断, 返回值推断, 函数推断, 属性推断, 类型反推, 索引访问操作符, 类型映射, 4.函数 (function), 函数的两种声明方式, 为函数定义类型, 函数的推断类型, 可选参数和默认参数, 剩余参数, this, this参数, 回调函数里的this参数, 函数的重载, 4.类(class), TS中定义类, 继承, 类中的修饰符, public  修饰符（公开属性), protected修饰符 (自己和子类可以访问到), private修饰符 （私有的）, readonly修饰符 （仅读）, 参数属性, 存取器, 静态属性和方法, Super属性 (继承 extends), 类的装饰器, 装饰类, 装饰类中属性, 装饰类中方法, 装饰参数, 抽象类, 高级技巧, 构造函数, 把类当做接口使用, 5.接口(interface), 文档的解释, 可选属性, 只读属性, readonly vs const, 额外的属性检查, 函数类型, 可索引的类型, 类 类型, 实现接口, 类静态部分与实例部分的区别, 继承接口, 混合类型, 接口继承类, 学习的解释, 函数接口参数, 函数类型接口, 函数混合类型, 对象接口, 任意属性、可索引接口, 类接口, 接口继承, 构造函数类型的环境搭一什么是是的超集遵循最新的规范扩展了语法更像后端让可以开发大型企业应用提供的类型系统可以帮助我们在写代码时提供丰富的语法提示在编写代码时会对代码进行类型检查从而避免很多线上错误不会取代尤雨溪我认为将类型添加到本身是一个漫长的过程让委员会设计一个类型系统是根据的经历来判断不切实际的二环境配置全局编译文件全局安装对进行编译生成可以将文件编译成文件监控文件变化生成文件配置环境安装依赖初始化配置文件配置操作文件默认打包的时候会查找当前目录下这个文件采用模块来编写配置文件中有模块规范默认是也可以改成模块规范当前文件的绝对路径当前文件的绝对路径当前文件所在的文件夹目录绝对路径打包的配置对象项目入口当前的文件在当前目录下的目录第三方包的入口入口文件可以是也可以是配置我们可以通过启动服务来使用啦文件我门在使用的时候需要将编写的代码转换成在运行这个模块来进行文件的编译全局的包只能在命令行中使用最终直接生成文件在运行初始化的配置文件比较适合临时测试的方式插件来实现代码的运行如果是文件内部会直接采用文件名来执行此文件如果是文件需要通过来直接执行通过构建工具将代码转化成在去运行最终便衣成执行基础类型中冒号后面的都为类型标识布尔类型布尔值最基本的数据类型就是简单的值在和里叫做其它语言中也一样数字类型数字和一样里的所有数字都是浮点数这些浮点数的类型是除了支持十进制和十六进制字面量还支持中引入的二进制和八进制字面量字符串类型字符串程序的另一项基本操作是处理网页或服务器端的文本数据像其它语言里一样我们使用表示文本数据类型和一样可以使用双引号或单引号表示字符串你还可以使用模版字符串它可以定义多行文本和内嵌表达式这种字符串是被反引号包围并且以这种形式嵌入表达式这与下面定义的方式效果相同数组像一样可以操作数组元素有两种方式可以定义数组第一种可以在元素类型后面接上表示由此类型元素组成的一个数组第二种方式是使用数组泛型元素类型元组类型元组类型允许表示一个已知元素数量和类型的数组各元素的类型不必相同比如你可以定义一对值分别为和类型的元组声明一个元组类型初始化初始化错误像元组中增加数据只能增加元组中存放的类型回龙观当访问一个已知索引的元素会得到正确的类型没有中当访问一个越界的元素会使用联合类型替代字符串可以赋值给类型和都有布尔不是类型你赋予的值要求得符合这个结构和顺序元组在新增内容的时候不能增加额外的类型的值只能是已有的而且增加后无法访问已经约定好没有第四个后续增加的不算访问的时候不能访问后增加安全问题枚举类型类型是对标准数据类型的一个补充像等其它语言一样使用枚举类型可以为一组数值赋予友好的名字常用于状态码权限数据格式标志位默认情况下从开始为元素编号你也可以手动的指定成员的数值例如我们将上面的例子改成从开始编号或者全部都采用手动赋值枚举类型提供的一个便利是你可以由枚举的值得到它的名字例如我们知道数值为但是不确定它映射到里的哪个名字我们可以查找相应的名字显示因为上面代码里它的值是默认从开始可以枚举也可以反举编译后的结果异构枚举常量枚举任意值有时候我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型这些值可能来自于动态的内容比如来自用户输入或第三方代码库这种情况下我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查那么我们可以使用类型来标记这些变量任何类型能不写就不要用会导致类型丧失检测如果我们的项目是采用编写的一般情况下的出现场景不多放弃检测出错就怨自己没有的加持这是是字符串可以的肯定是布尔值在对现有代码进行改写的时候类型是十分有用的它允许你在编译时可选择地包含或移除类型检查你可能认为有相似的作用就像它在其它语言中那样但是类型的变量只是允许你给它赋任意值但是却不能够在它上面调用任意的方法即便它真的有这些方法可能在运行时存在好的存在但编译器不检查错误属性在类型上不存在当你只知道一部分数据的类型时类型也是有用的比如你有一个数组它包含了不同的类型的数据空值某种程度上来说类型像是与类型相反它表示没有任何类型当一个函数没有返回值时你通常会见到其返回值类型是只能接受一般用于函数的返回值严格模式下不能将赋予给类型代表的是空类型这个一般值表示函数的返回值可以赋予给都代表空是的子类型这是我的警告信息声明一个类型的变量没有什么大用因为你只能为它赋予和和里和两者各自有自己的类型分别叫做和和相似它们的本身的类型用处不是很大我们不能给这些变量赋多少别的值默认情况下和是所有类型的子类型就是说你可以把和赋值给类型的变量如果禁用非严格检测和可以赋予给任何类型任何类型的子类型如果的值为则不能把和付给其他类型然而当你指定了标记和只能赋值给和它们各自这能避免很多常见的问题也许在某处你想传入一个或或你可以使用联合类型再次说明稍后我们会介绍联合类型注意我们鼓励尽可能地使用但在本手册里我们假设这个标记是关闭的类型表示的是那些永不存在的值的类型例如类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型变量也可能是类型当它们被永不为真的类型保护所约束时类型是任何类型的子类型也可以赋值给任何类型代表不会出现的值不能把其他类型赋值给然而没有类型是的子类型或可以赋值给类型除了本身之外即使也不可以赋值给下面是一些返回类型的函数返回的函数必须存在无法达到的终点推断的返回值类型为返回的函数必须存在无法达到的终点永远不永远达到不了的地方就是出错函数无法执行完毕函数无法执行完毕函数无法达到执行完毕的状态如果条件都走完了没有遗漏的后面的类型就是完整性保护类型只能被类型来赋予值类型表示独一无二类型类型和类型是不兼容的对象类型练习代码关注的是类型不是业务逻辑类型的分类基础类型高级类型内置类型自定义类型类型体操的类型都是在变量后面来写后面是类型后面是值语法不是对象的特点如何来学习的目的是什么从安全角度来考虑使用考虑我在赋予结果的时候是否会发生错误是用来检测类型的只是提示作用不是在运行的时候发生的运行的时候和无关代码没有被执行编译之后类型就消失了不存在类型了写的都是空气最终生生产环境下可以增添来对文件增加类型声明的特点在编写代码的时候并不是所有的变量都要添加类型中支持类型推导根据赋的值来猜测他的类型如果猜测的类型是对的不用给类型如果猜测的不对或者类型无法正确的推导自己写类型基础类型包装类型规范小写的类型一般用于描述基本类型大写的用来描述的是实例类型在赋予值的时候子集可以赋予给父级类的类型类类型用来描述实例的我们在使用基本类型的时候需要采用的时候小写类型来标识数组的概念用于存储多个类型相同的集合类型类型都可以用于声明数组数组要求的是存储的格式按照特定类型来存储不关心位置元组你赋予的值要求得符合这个结构和顺序元组在新增内容的时候不能增加额外的类型的值只能是已有的而且增加后无法访问已经约定好没有第四个后续增加的不算访问的时候不能访问后增加安全问题枚举自带类型的对象自己有类型就是一个对象约定一组格式我们会用枚举状态码权限数据格式标志位维护一组常量的时候可以采用枚举常量枚举不会额外编译成对象所以更节约类型可以进行反举值是数字的时候可以反过来枚举枚举没有值会根据上面的索引来自动累加异构枚举就是枚举中不光有数字还有字符串异构枚举上一个是字符串下一个无法推导基本类型正常情况下只能赋予给和如果禁用非严格检测和可以赋予给任何类型任何类型的子类型类型代表的是空类型这个一般值表示函数的返回值可以赋予给都代表空是的子类型永远不永远达到不了的地方就是函数无法执行完毕函数无法达到执行完毕的状态出错函数无法执行完毕如果条件都走完了没有遗漏的后面的类型就是完整性保护类型只能被类型来赋予值代码的完整性保护任何类型能不写就不要用会导致类型丧失检测如果我们的项目是采用编写的一般情况下的出现场景不多放弃检测出错就怨自己没有的加持引用类型的区别非严格模式在关闭的时候可以赋予给数组元组枚举这是一个独立的模块不好影响其他人类型推导一类型推导声明变量没有赋予值时默认变量是类型类型为声明变量赋值时则以赋值类型为准被推导为字符串类型里在有些没有明确指出类型的地方类型推论会帮助提供类型如下面的例子类型被推导为变量的类型被推断为数字这种推断发生在初始化变量和成员设置默认参数值和决定函数返回值时类型被推导为为了推断的类型我们必须考虑所有元素的类型这里有两种选择和计算通用类型算法会考虑所有的候选类型并给出一个兼容所有候选类型的类型由于最终的通用类型取自候选类型有些时候候选类型共享相同的通用类型但是却没有一个类型能做为所有候选类型的类型例如这里我们想让被推断为类型但是这个数组里没有对象是类型的因此不能推断出这个结果为了更正当候选类型不能使用的时候我们需要明确的指出类型是常量意味着定义的值不会修改所以他的类型是一个字面量类型声明变量必须复制声明变量可以修改所以类型范围推到的结果会变大上下文类型类型推论也可能按照相反的方向进行这被叫做按上下文归类按上下文归类会发生在表达式的类型与所处的位置相关时比如这个例子会得到一个类型错误类型检查器使用函数的类型来推断右边函数表达式的类型因此就能推断出参数的类型了如果函数表达式不是在上下文类型的位置参数的类型需要指定为这样也不会报错了如果上下文类型表达式包含了明确的类型信息上下文的类型被忽略重写上面的例子这个函数表达式有明确的参数类型注解上下文类型被忽略这样的话就不报错了因为这里不会使用到上下文类型上下文归类会在很多情况下使用到通常包含函数的参数赋值表达式的右边类型断言对象成员和数组字面量和返回值语句上下文类型也会做为最佳通用类型的候选类型比如这个例子里最佳通用类型有个候选者和当然会被做为最佳通用类型二包装对象我们在使用基本数据类型时调用基本数据类型上的方法默认会将原始数据类型包装成对象类型是基本数据类型是他的封装类三联合类型联合类型与交叉类型很有关联但是使用上却完全不同偶尔你会遇到这种情况一个代码库希望传入或类型的参数例如下面的函数获取一个字符串并在左侧添加如果是一个字符串那么会被添加到左侧如果是一个数字那么这个数量的空格将被添加到左侧存在一个问题参数的类型指定成了这就是说我们可以传入一个既不是也不是类型的参数但是却不报错编译阶段通过运行时报错在传统的面向对象语言里我们可能会将这两种类型抽象成有层级的类型这么做显然是非常清晰的但同时也存在了过度设计原始版本的好处之一是允许我们传入原始类型这样做的话使用起来既简单又方便如果我们就是想使用已经存在的函数的话这种新的方式就不适用了代替我们可以使用联合类型做为的参数联合类型表示一个值可以是几种类型之一我们用竖线分隔每个类型所以表示一个值可以是或如果一个值是联合类型我们只能访问此联合类型的所有类型里共有的成员这里的联合类型可能有点复杂但是你很容易就习惯了如果一个值的类型是我们能够确定的是它包含了和中共有的成员这个例子里具有一个成员我们不能确定一个类型的变量是否有方法如果变量在运行时是类型那么调用就出错了在使用联合类型时没有赋值只能访问联合类型中共有的方法和属性如果是联合类型在使用方法的时候只能采用公共的方法来使用还是从安全性考虑在使用联合类型的时候我门通过会先定义值在使用保证安全联合类型公共方法方法字符串方法这里的表示此值非空断定元素一定有值可辨识联合你可以合并单例类型联合类型类型保护和类型别名来创建一个叫做可辨识联合的高级模式它也称做标签联合或代数数据类型可辨识联合在函数式编程很有用处一些语言会自动地为你辨识联合而则基于已有的模式它具有个要素具有普通的单例类型属性可辨识的特征一个类型别名包含了那些类型的联合联合此属性上的类型保护首先我们声明了将要联合的接口每个接口都有属性但有不同的字符串字面量类型属性称做可辨识的特征或标签其它的属性则特定于各个接口注意目前各个接口间是没有联系的下面我们把它们联合到一起现在我们使用可辨识联合四类型断言类型断言类型断言有两种形式其一是尖括号语法另一个为语法我门断言类型后在使用断言成某种类型一定是联合类型中的某一个非空断言表示这个值一定不是空的不存在结果你自己承担不管了你认为的一定有值强制语法语法链判断运算符如果值有再去取值表示的是取值操作不能赋值表示某个变量一定存在语法合并空值运算符三元表达式但是取的结果除了和其他都是双重断言尽量不要使用双重断言会破坏原有类型关系断言为是因为类型可以被赋值给其他类型五字面量类型可以用字面量当做类型同时也表明只能采用这几个值限定值类似枚举字符串字面量类型字符串字面量类型允许你指定字符串必须的固定值在实际应用中字符串字面量类型可以与联合类型类型保护和类型别名很好的配合通过结合使用这些特性你可以实现类似枚举类型的字符串错误此处不允许使用你只能从三种允许的字符中选择其一来做为参数传递传入其它值则会产生错误类型的参数不能赋值给类型的参数字符串字面量类型还可以用于区分函数重载数字字面量类型还具有数字字面量类型我们很少直接这样使用但它们可以用在缩小范围调试的时候换句话说当与进行比较的时候它的值必须为这就意味着上面的比较检查是非法的类型别名类型别名会给一个类型起个新名字类型别名有时和接口很像但是可以作用于原始值联合类型元组以及其它任何你需要手写的类型起别名起别名不会新建一个类型它创建了一个新名字来引用那个类型给原始类型起别名通常没什么用尽管可以做为文档的一种形式使用同接口一样类型别名也可以是泛型我们可以添加类型参数并且在别名声明的右侧传入起别名我们也可以使用类型别名来在属性里引用自己与交叉类型一起使用我们可以创建出一些十分稀奇古怪的类型然而类型别名不能出现在声明右侧的任何地方报错接口类型别名像我们提到的类型别名可以像接口一样然而仍有一些细微差别其一接口创建了一个新的名字可以在其它任何地方使用类型别名并不创建新名字比如错误信息就不会使用别名在下面的示例代码里在编译器中将鼠标悬停在上显示它返回的是但悬停在上时显示的却是对象字面量类型另一个重要区别是类型别名不能被和自己也不能和其它类型因为软件中的对象应该对于扩展是开放的但是对于修改是封闭的你应该尽量去使用接口代替类型别名另一方面如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型这时通常会使用类型别名赋值推断赋值时推断类型从右像左流动会根据赋值推断出变量类型返回值推断自动推断函数返回值类型函数推断函数从左到右进行推断属性推断可以通过属性值推断出属性的类型类型反推可以使用关键字反推变量类型索引访问操作符类型映射练习代码声明类型的时候如果没有标识类型他是什么类型没有复制的变量默认值是但是类型是是常量意味着定义的值不会修改所以他的类型是一个字面量类型声明变量必须复制声明变量可以修改所以类型范围推到的结果会变大断言的问题如果是联合类型在使用方法的时候只能采用公共的方法来使用还是从安全性考虑在使用联合类型的时候我门通过会先定义值在使用保证安全指定类型在使用我门断言类型后在使用断言成某种类型一定是联合类型中的某一个非空断言表示这个值一定不是空的不存在结果你自己承担不管了你认为的一定有值语法语法链判断运算符如果值有再去取值表示的是取值操作不能赋值表示某个变量一定存在语法合并空值运算符三元表达式但是取的结果除了和其他都是值或者值一般用于联合类型将大范围的类型断言成子类型双重断言一般不建议使用但是还会用到破坏原有的关系类型别名将类型提取出来快速构建一个可以复用的类型函数函数中的类型函数的声明方式函数的参数函数的返回值关键字来声明的函数可以提升到当前作用域顶部对于来说有区别函数关键字声明的函数不能标注函数类型通过表达式来声明的函数必须赋予的值要满足定义的类型要求有一个兼容性在里面函数的两种声明方式通过关键字来进行声明可以用来限制函数的参数和返回值类型通过表达式方式声明为函数定义类型书写完整函数类型函数类型的定义如果标明函数的类型在使用函数的时候以标明的为准只要参数类型是匹配的那么就认为它是有效的函数类型而不在乎参数名是否正确第二部分是返回值类型对于返回值我们在函数和返回值类型之前使用符号使之清晰明了如之前提到的返回值类型是函数类型的必要部分如果函数没有返回任何值你也必须指定返回值类型为而不能留空函数的类型只是由参数类型和返回值组成的函数中使用的捕获变量不会体现在类型里实际上这些变量是函数的隐藏状态并不是组成的一部分函数的推断类型尝试这个例子的时候你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话编译器会自动识别出类型具有完整的函数类型参数和的类型是这叫做按上下文归类是类型推论的一种它帮助我们更好地为程序指定类型可选参数和默认参数里的每个函数参数都是必须的这不是指不能传递或作为参数而是说编译器检查用户是否为每个参数都传入了值编译器还会假设只有这些参数会被传递进函数简短地说传递给一个函数的参数个数必须与函数期望的参数个数一致缺少参数多余参数刚刚好可选参数里每个参数都是可选的可传可不传没传参的时候它的值就是在里我们可以在参数名旁使用实现可选参数的功能比如我们想让是可选的现在可以正常工作了参数太多刚刚好可选参数必须跟在必须参数后面如果上例我们想让是可选的那么就必须调整它们的位置把放在后面参数可选参数可选参数意味着可以不传和必须得传可选参数只能在参数列表中的后面可选参数必须在其他参数的最后面这里如果是兼容处理采用的是自己标识的不是你复制的类型可选参数必须在其他参数的最后面默认参数在里我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是时它们叫做有默认初始化值的参数让我们修改上例把的默认值设置为现在工作正常返回仍然有效也返回参数太多刚刚好在所有必须参数后面的带默认初始化的参数都是可选的与可选参数一样在调用函数的时候可以省略也就是说可选参数与末尾的默认参数共享参数类型和共享同样的类型默认参数的默认值消失了只保留了它是一个可选参数的信息与普通可选参数不同的是带默认值的参数不需要放在必须参数的后面如果带默认值的参数出现在必须参数前面用户必须明确的传入值来获得默认值例如我们重写最后一个例子让是带默认值的参数参数太少参数太多返回返回默认参数必须在其他参数的最后面函数中有但是我们不建议使用函数式编程入参和返回值组合式函数不考虑使用和参数的类型直接参数后面标识函数的返回值在前面来标识剩余参数必要参数默认参数和可选参数有个共同点它们表示某一个参数有时你想同时操作多个参数或者你并不知道会有多少参数传递进来在里你可以使用来访问所有传入的参数函数中有但是我们不建议使用在里你可以把所有参数收集到一个变量里剩余参数会被当做个数不限的可选参数可以一个都没有同样也可以有任意个编译器创建参数数组名字是你在省略号后面给定的名字你可以在函数体内使用这个数组这个省略号也会在带有剩余参数的函数类型定义上使用到函数式编程入参和返回值组合式函数不考虑使用和参数的类型直接参数后面标识函数的返回值在前面来标识学习如何在里正确使用就好比一场成年礼由于是的超集程序员也需要弄清工作机制并且当有的时候能够找出错误所在幸运的是能通知你错误地使用了的地方如果你想了解里的是如何工作的那么首先阅读写的的文章详细的阐述了的内部工作原理因此我们这里只做简单介绍和箭头函数里的值在函数被调用的时候才会指定这是个既强大又灵活的特点但是你需要花点时间弄清楚函数调用的上下文是什么但众所周知这不是一件很简单的事尤其是在返回一个函数或将函数当做参数传递的时候下面看一个例子可以看到是个函数并且它又返回了一个函数如果我们尝试运行这个程序会发现它并没有弹出对话框而是报错了因为返回的函数里的被设置成了而不是对象因为我们只是独立的调用了顶级的非方法式调用会将视为注意在严格模式下为而不是为了解决这个问题我们可以在函数被返回时就绑好正确的这样的话无论之后怎么使用它都会引用绑定的对象我们需要改变函数表达式来使用箭头语法箭头函数能保存函数创建时的值而不是调用时的值更好事情是会警告你犯了一个错误如果你给编译器设置了标记它会指出里的的类型为参数尽量不采用来作为函数的上下文的缺陷就是类型推导问题如果想限制类型那么需要手动指定类型不是行参是标明的类型不幸的是的类型依旧为这是因为来自对象字面量里的函数表达式修改的方法是提供一个显式的参数参数是个假的参数它出现在参数列表的最前面让我们往例子里添加一些接口和让类型重用能够变得清晰简单些现在知道期望在某个对象上调用也就是说是类型的而非因此不会报错了回调函数里的参数当你将一个函数传递到某个库函数里在稍后被调用时你可能也见到过回调函数里的会报错因为当回调函数被调用时它会被当成一个普通函数调用将为稍做改动你就可以通过参数来避免错误首先库函数的作者要指定的类型意味着期望是一个函数且它不需要一个类型然后为调用代码里的添加类型注解指定了类型后你显式声明必须在的实例上调用然后会检测到要求函数带有改变类型来修复这个错误因为指定了类型为因此传递是合法的当然了这也意味着不能使用如果你两者都想要你不得不使用箭头函数了这是可行的因为箭头函数不会捕获所以你总是可以把它们传给期望的函数缺点是每个对象都会创建一个箭头函数另一方面方法只会被创建一次添加到的原型链上它们在不同对象间是共享的函数的重载本身是个动态语言里函数根据传入不同的参数而返回不同类型的数据是很常见的中函数有一个概念叫重载类型的重载对于强类型语言可以一个函数写多遍参数不同实现重载考的是方法根据传入参数的不同会返回两种不同的类型如果传入的是代表纸牌的对象函数作用是从中抓一张牌如果用户想抓牌我们告诉他抓到了什么牌但是这怎么在类型系统里表示呢方法是为同一个函数提供多个函数类型定义来进行函数重载编译器会根据这个列表去处理函数的调用下面我们来重载函数这样改变后重载的函数在调用的时候会进行正确的类型检查为了让编译器能够选择正确的检查类型它与里的处理流程相似它查找重载列表尝试使用第一个重载定义如果匹配的话就使用这个因此在定义重载的时候一定要把最精确的定义放在最前面注意并不是重载列表的一部分因此这里只有两个重载一个是接收对象另一个接收数字以其它参数调用会产生错误具体的某一种方案上面的声明仅仅是类型上的重载所有的实现根据传入不同类型的数据返回不同的结果练习代码函数中的类型函数的声明方式函数的参数函数的返回值关键字来声明的函数可以提升到当前作用域顶部对于来说有区别函数关键字声明的函数不能标注函数类型通过表达式来声明的函数必须赋予的值要满足定义的类型要求有一个兼容性在里面函数类型的定义如果标明函数的类型在使用函数的时候以标明的为准参数可选参数可选参数意味着可以不传和必须得传可选参数只能在参数列表中的后面默认值这里如果是兼容处理采用的是自己标识的不是你复制的类型参数问题尽量不采用来作为函数的上下文的缺陷就是类型推导问题如果想限制类型那么需要手动指定类型不是行参是标明的类型我想根据值来获得类型配合来声明新的类型可以获取对象中的类型作为联合类型昌平霍营提取对象的类型为类型会提升到顶部可以将子类型赋予给父类型函数中有但是我们不建议使用函数式编程入参和返回值组合式函数不考虑使用和参数的类型直接参数后面标识函数的返回值在前面来标识中函数有一个概念叫重载类型的重载对于强类型语言可以一个函数写多遍参数不同实现重载考的是入参是一个字符串或者是数字字符串数字具体的某一种方案上面的声明仅仅是类型上的重载所有的实现类类类的组成构造函数属性实例属性原型属性静态属性方法实例的方法原型方法静态方法访问器静态相关的配置中定义类实例上的属性必须先声明给这个类来声明属性函数实例上的属性需要先声明在使用构造函数中的参数可以使用可选参数和剩余参数如果你使用过或你会对这种语法非常熟悉我们声明一个类这个类有个成员一个叫做的属性一个构造函数和一个方法你会注意到我们在引用任何一个类成员的时候都用了它表示我们访问的是类的成员最后一行我们使用构造了类的一个实例它会调用之前定义的构造函数创建一个类型的新对象并执行构造函数初始化它继承在里我们可以使用常用的面向对象模式基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类看下面的例子这个例子展示了最基本的继承类从基类中继承了属性和方法这里是一个派生类它派生自基类通过关键字派生类通常被称作子类基类通常被称作超类因为继承了的功能因此我们可以创建一个的实例它能够和下面我们来看个更加复杂的例子这个例子展示了一些上面没有提到的特性这一次我们使用关键字创建了的两个子类和与前一个例子的不同点是派生类包含了一个构造函数它必须调用它会执行基类的构造函数而且在构造函数里访问的属性之前我们一定要调用这个是强制执行的一条重要规则这个例子演示了如何在子类里可以重写父类的方法类和类都创建了方法它们重写了从继承来的方法使得方法根据不同的类而具有不同的功能注意即使被声明为类型但因为它的值是调用时它会调用里重写的方法类中的修饰符修饰符公开属性公开属性类的实例在外部可以访问这个属性类的内部也可以访问继承的子类也可以访问不写默认也是公开的子类访问外层访问我们可以通过参数属性来简化父类中的代码修饰符自己和子类可以访问到我自己能访问儿子能访问外部无法访问无法访问修饰符私有的除了自己都访问不到无法访问无法访问修饰符仅读标识仅读属性意味着如果初始化后不能被修改仅读属性只能在中被赋值参数属性在上面的例子中我们不得不定义一个受保护的成员和一个构造函数参数在类里并且立刻给和赋值这种情况经常会遇到参数属性可以方便地让我们在一个地方定义并初始化一个成员下面的例子是对之前类的修改版使用了参数属性注意看我们是如何舍弃了仅在构造函数里使用参数来创建和初始化成员我们把声明和赋值合并至一处参数属性通过给构造函数参数添加一个访问限定符来声明使用限定一个参数属性会声明并初始化一个私有成员对于和来说也是一样存取器支持通过来截取对对象成员的访问它能帮助你有效的控制对对象成员的访问下面来看如何把一个简单的类改写成使用和首先我们从一个没有使用存取器的例子开始我们可以随意的设置这是非常方便的但是这也可能会带来麻烦下面这个版本里我们先检查用户密码是否正确然后再允许其修改员工信息我们把对的直接访问改成了可以检查密码的方法我们也加了一个方法让上面的例子仍然可以工作我们可以修改一下密码来验证一下存取器是否是工作的当密码不对时会提示我们没有权限去修改员工对于存取器有下面几点需要注意的首先存取器要求你将编译器设置为输出或更高不支持降级到其次只带有不带有的存取器自动被推断为这在从代码生成文件时是有帮助的因为利用这个属性的用户会看到不允许够改变它的值静态属性和方法创建类的静态成员这些属性存在于类本身上面而不是类的实例上在这个例子里我们使用定义因为它是所有网格都会用到的属性每个实例想要访问这个属性的时候都要在前面加上类名如同在实例属性上使用前缀来访问属性一样这里我们使用来访问静态属性哺乳动物静态属性静态方法动物类属性访问器静态属性和静态方法是可以被子类所继承的等价于每个属性增添了原型方法就是每一个实例共享的方法父类提供的方法子类是可以进行方法重写的原型的函数意味着是不关心函数的返回值并不是空的意思原型属性需要通过访问器来实现属性继承动物原型方法中的指代的是父类的原型猫猫叫静态方法中的指代的是父类在构造函数指向的是父类在原型的方法中调用的时候指向的是父类的原型在类中访问函数中执指向的都是父类在原型方法中属性访问器都是父类的原型在构造函数指向的是父类在原型的方法中调用的时候指向的是父类的原型子类在重写父类方法要兼容赋予的函数可以兼容父类自己本身创造一个实例后续一致用这一个不产生多个增加之后构造函数不能被了类在什么时候不用外面在里我们可以使用常用的面向对象模式基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类看下面的例子这个例子展示了最基本的继承类从基类中继承了属性和方法这里是一个派生类它派生自基类通过关键字派生类通常被称作子类基类通常被称作超类因为继承了的功能因此我们可以创建一个的实例它能够和下面我们来看个更加复杂的例子这个例子展示了一些上面没有提到的特性这一次我们使用关键字创建了的两个子类和与前一个例子的不同点是派生类包含了一个构造函数它必须调用它会执行基类的构造函数而且在构造函数里访问的属性之前我们一定要调用这个是强制执行的一条重要规则这个例子演示了如何在子类里可以重写父类的方法类和类都创建了方法它们重写了从继承来的方法使得方法根据不同的类而具有不同的功能注意即使被声明为类型但因为它的值是调用时它会调用里重写的方法类的装饰器装饰类装饰类可以给类扩展功能需要开启装饰类中属性装饰属性可以对属性的内容进行改写装饰的是实例属性则指向类的原型装饰的是静态属性则执行类本身装饰类中方法不可枚举装饰参数抽象类抽象类做为其它派生类的基类使用它们一般不会直接被实例化不同于接口抽象类可以包含成员的实现细节关键字是用于定义抽象类和在抽象类内部定义抽象方法抽象类中的抽象方法不包含具体实现并且必须在派生类中实现抽象方法的语法与接口方法相似两者都是定义方法签名但不包含方法体然而抽象方法必须包含关键字并且可以包含访问修饰符必须在派生类中实现在派生类的构造函数中必须调用允许创建一个对抽象类型的引用错误不能创建一个抽象类的实例允许对一个抽象子类进行实例化和赋值错误方法在声明的抽象类中不存在抽象类无法被实例化只能被继承抽象方法不能在抽象类中实现只能在抽象类的具体子类中实现而且必须实现猫猫叫汪汪叫定义类型时表示函数的返回值为空不关心返回值类型所有在定义函数时也不关心函数返回值类型中有抽象类概念不存在的抽象类可以含义非抽象的方法和属性不会它抽象类可以被继承抽象类中抽象方法子类必须要实现非抽象已经有实现了喝水抽象的方法父类没有实现那么子类必须实现因为我们编写的代码的时候慢慢的脱离继承了组合优于继承类的装饰器高级技巧构造函数当你在里声明了一个类的时候实际上同时声明了很多东西首先就是类的实例的类型这里我们写了意思是类的实例的类型是这对于用过其它面向对象语言的程序员来讲已经是老习惯了我们也创建了一个叫做构造函数的值这个函数会在我们使用创建类实例的时候被调用下面我们来看看上面的代码被编译成后是什么样子的上面的代码里将被赋值为构造函数当我们调用并执行了这个函数后便会得到一个类的实例这个构造函数也包含了类的所有静态属性换个角度说我们可以认为类具有实例部分与静态部分这两个部分让我们稍微改写一下这个例子看看它们之前的区别这个例子里与之前看到的一样我们实例化类并使用这个对象与我们之前看到的一样再之后我们直接使用类我们创建了一个叫做的变量这个变量保存了这个类或者说保存了类构造函数然后我们使用意思是取类的类型而不是实例的类型或者更确切的说告诉我标识符的类型也就是构造函数的类型这个类型包含了类的所有静态成员和构造函数之后就和前面一样我们在上使用创建的实例把类当做接口使用如上一节里所讲的类定义会创建两个东西类的实例类型和一个构造函数因为类可以创建出类型所以你能够在允许使用接口的地方使用类练习代码类类的组成构造函数属性实例属性原型属性静态属性方法实例的方法原型方法静态方法访问器静态相关的配置给这个类来声明属性函数类的修饰符公开属性类的实例在外部可以访问这个属性类的内部也可以访问继承的子类也可以访问我自己能访问儿子能访问外部无法访问私有的自己能访问平时我们一般采用或者的场景比较多标识仅读属性意味着如果初始化后不能被修改等价于每个属性增添了原型方法就是每一个实例共享的方法父类提供的方法子类是可以进行方法重写的原型的函数意味着是不关心函数的返回值并不是空的意思原型属性需要通过访问器来实现在构造函数指向的是父类在原型的方法中调用的时候指向的是父类的原型子类在重写父类方法要兼容赋予的函数可以兼容父类以上用法同在类中访问函数中执指向的都是父类在原型方法中属性访问器都是父类的原型自己本身创造一个实例后续一致用这一个不产生多个增加之后构造函数不能被了类在什么时候不用外面中有抽象类概念不存在的抽象类可以含义非抽象的方法和属性不会它抽象类可以被继承抽象类中抽象方法子类必须要实现非抽象已经有实现了喝水抽象的方法父类没有实现那么子类必须实现因为我们编写的代码的时候慢慢的脱离继承了组合优于继承类的装饰器接口文档的解释类型检查器会查看的调用有一个参数并要求这个对象参数有一个名为类型为的属性需要注意的是我们传入的对象参数实际上会包含很多属性但是编译器只会检查那些必需的属性是否存在并且其类型是否匹配然而有些时候却并不会这么宽松我们下面会稍做讲解下面我们重写上面的例子这次使用接口来描述必须包含一个属性且类型为接口就好比一个名字用来描述上面例子里的要求它代表了有一个属性且类型为的对象需要注意的是我们在这里并不能像在其它语言里一样说传给的对象实现了这个接口我们只会去关注值的外形只要传入的对象满足上面提到的必要条件那么它就是被允许的还有一点值得提的是类型检查器不会去检查属性的顺序只要相应的属性存在并且类型也是对的就可以可选属性接口里的属性不全都是必需的有些是只在某些条件下存在或者根本不存在可选属性在应用模式时很常用即给函数传入的参数对象中只有部分属性赋值了下面是应用了的例子带有可选属性的接口与普通的接口定义差不多只是在可选属性名字定义的后面加一个符号可选属性的好处之一是可以对可能存在的属性进行预定义好处之二是可以捕获引用了不存在的属性时的错误比如我们故意将里的属性名拼错就会得到一个错误提示只读属性一些对象属性只能在对象刚刚创建的时候修改其值你可以在属性名前用来指定只读属性你可以通过赋值一个对象字面量来构造一个赋值后和再也不能被改变了具有类型它与相似只是把所有可变方法去掉了因此可以确保数组创建后再也不能被修改上面代码的最后一行可以看到就算把整个赋值到一个普通数组也是不可以的但是你可以用类型断言重写最简单判断该用还是的方法是看要把它做为变量使用还是做为一个属性做为变量使用的话用若做为属性则使用额外的属性检查我们在第一个例子里使用了接口让我们传入到仅期望得到的函数里我们已经学过了可选属性并且知道他们在模式里很有用然而天真地将这两者结合的话就会像在里那样搬起石头砸自己的脚比如拿例子来说注意传入的参数拼写为而不是在里这会默默地失败你可能会争辩这个程序已经正确地类型化了因为属性是兼容的不存在属性而且额外的属性是无意义的然而会认为这段代码可能存在对象字面量会被特殊对待而且会经过额外属性检查当将它们赋值给变量或作为参数传递的时候如果一个对象字面量存在任何目标类型不包含的属性时你会得到一个错误绕开这些检查非常简单最简便的方法是使用类型断言然而最佳的方式是能够添加一个字符串索引签名前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性如果带有上面定义的类型的和属性并且还会带有任意数量的其它属性那么我们可以这样定义它我们稍后会讲到索引签名但在这我们要表示的是可以有任意数量的属性并且只要它们不是和那么就无所谓它们的类型是什么还有最后一种跳过这些检查的方式这可能会让你感到惊讶它就是将这个对象赋值给一个另一个变量因为不会经过额外属性检查所以编译器不会报错要留意在像上面一样的简单代码里你可能不应该去绕开这些检查对于包含方法和内部状态的复杂对象字面量来讲你可能需要使用这些技巧但是大部额外属性检查错误是真正的就是说你遇到了额外类型检查出的错误比如你应该去审查一下你的类型声明在这里如果支持传入或属性到你应该修改定义来体现出这一点函数类型接口能够描述中对象拥有的各种各样的外形除了描述带有属性的普通对象外接口也可以描述函数类型为了使用接口表示函数类型我们需要给接口定义一个调用签名它就像是一个只有参数列表和返回值类型的函数定义参数列表里的每个参数都需要名字和类型这样定义后我们可以像使用其它接口一样使用这个函数类型的接口下例展示了如何创建一个函数类型的变量并将一个同类型的函数赋值给这个变量对于函数类型的类型检查来说函数的参数名不需要与接口里定义的名字相匹配比如我们使用下面的代码重写上面的例子函数的参数会逐个进行检查要求对应位置上的参数类型是兼容的如果你不想指定类型的类型系统会推断出参数类型因为函数直接赋值给了类型变量函数的返回值类型是通过其返回值推断出来的此例是和如果让这个函数返回数字或字符串类型检查器会警告我们函数的返回值类型与接口中的定义不匹配可索引的类型与使用接口描述函数类型差不多我们也可以描述那些能够通过索引得到的类型比如或可索引类型具有一个索引签名它描述了对象索引的类型还有相应的索引返回值类型让我们看一个例子上面例子里我们定义了接口它具有索引签名这个索引签名表示了当用去索引时会得到类型的返回值共有支持两种索引签名字符串和数字可以同时使用两种类型的索引但是数字索引的返回值必须是字符串索引返回值类型的子类型这是因为当使用来索引时会将它转换成然后再去索引对象也就是说用一个去索引等同于使用一个去索引因此两者需要保持一致错误使用索引有时会得到字符串索引签名能够很好的描述模式并且它们也会确保所有属性与其返回值类型相匹配因为字符串索引声明了和两种形式都可以下面的例子里的类型与字符串索引类型不匹配所以类型检查器给出一个错误提示可以是类型错误的类型与索引类型返回值的类型不匹配最后你可以将索引签名设置为只读这样就防止了给索引赋值你不能设置因为索引签名是只读的类类型实现接口与或里接口的基本作用一样也能够用它来明确的强制一个类去符合某种契约你也可以在接口中描述一个方法在类里实现它如同下面的方法一样接口描述了类的公共部分而不是公共和私有两部分它不会帮你检查类是否具有某些私有成员类静态部分与实例部分的区别当你操作类和接口的时候你要知道类是具有两个类型的静态部分的类型和实例的类型你会注意到当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误这里因为当一个类实现了一个接口时只对其实例部分进行类型检查存在于类的静态部分所以不在检查的范围内因此我们应该直接操作类的静态部分看下面的例子我们定义了两个接口为构造函数所用和为实例方法所用为了方便我们定义一个构造函数它用传入的类型创建实例因为的第一个参数是类型在里会检查是否符合构造函数签名继承接口和类一样接口也可以相互继承这让我们能够从一个接口里复制成员到另一个接口里可以更灵活地将接口分割到可重用的模块里一个接口可以继承多个接口创建出多个接口的合成接口混合类型先前我们提过接口能够描述里丰富的类型因为其动态灵活的特点有时你会希望一个对象可以同时具有上面提到的多种类型一个例子就是一个对象可以同时做为函数和对象使用并带有额外的属性在使用第三方库的时候你可能需要像上面那样去完整地定义类型接口继承类当接口继承了一个类类型时它会继承类的成员但不包括其实现就好像接口声明了所有类中存在的成员但并没有提供具体实现一样接口同样会继承到类的和成员这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时这个接口类型只能被这个类或其子类所实现当你有一个庞大的继承结构时这很有用但要指出的是你的代码只在子类拥有特定属性时起作用这个子类除了继承至基类外与基类没有任何关系例在上面的例子里包含了的所有成员包括私有成员因为是私有成员所以只能够是的子类们才能实现接口因为只有的子类才能够拥有一个声明于的私有成员这对私有成员的兼容性是必需的在类内部是允许通过的实例来访问私有成员的实际上就像一样并拥有一个方法和类是的子类因为它们都继承自并有方法但和类并不是这样的学习的解释接口可以在面向对象编程中表示行为的抽象也可以描述对象的形状接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约接口中不能含有具体的实现逻辑接口抽象类有抽象的也有非抽象接口必须都是抽象的没有具体的实现接口的概念就是描述数据的结构或者形状的定义好结构在去针对结构来进行实现和区别一般情况下描述对象类我门采用更多一些无法声明联合类型可以快速声明类型联合类型工具类型只能采用不能重名用的更多能用就不能用复杂类型采用函数接口参数我们可以约束函数中的参数但是类型无法复用接口可以描述对象结构子可以赋予给父类型不是具体实现子可以赋予给父亲我们需要把一个值赋予给另一个值如果是声明的必须必须一致地址赋值的时候会产生兼容性儿子可以赋予给父亲我们可以通过接口进行描述函数类型接口标识此值不能修改可以修改的如果给函数增加类型定义函数不能被修改时只能用通过接口限制函数的参数类型和返回值类型函数混合类型限制函数类型限制函数上的属性对象接口对象接口可以用来描述对象的形状结构可以通过表示接口的属性可有可无仅读属性不能进行修改标识的属性为可选属性标识的属性则不能修改多个同名的接口会自动合并断言的方式来进行赋值用的最多接口的合并同名的会进行合并自定义类型的时候会使用自己的业务逻辑用的比较少可以扩展一个新类型在来使用可以扩展属性任意类型随机的属性描述数字索引的除了必有的属性之外其他任意兼容性蔬菜多余的属性可以使用类型断言只读属性红色任意接口随意值随意西红柿甜红色任意属性可索引接口回龙观索引接口通过索引访问符来获取内部类型可以用于取值的类型取值的类型可以采用这种方式任意属性可以对某一部分必填属性做限制其余的可以随意增减可索引接口可以用于标识数组类接口这里先来强调一下抽象类和接口的区别抽象类中可以包含具体方法实现接口中不能包含实现接口可以实现接口的实现都是通过类来实现接口中一个类可以实现多个接口一个接口可以继承多个接口接口可以用于继承类一个类可以实现多个接口在类中必须实现接口中的方法和属性实现的是原型方法实现的是实例方法我门如何表示我要传入的是一个类类类型不能藐视类本身描述的是实例类的类型需要通过来取类型的校验规则鸭子类型检测描述构造函数泛型泛型坑位函数的形式参数刚开始类型不确定通过使用的时候来确定类型接口继承构造函数类型传入的是一个构造函数这里无法标识返回值类型表示当前是一个构造函数类型这里捎带使用了下泛型在使用时动态传入类型练习代码接口抽象类有抽象的也有非抽象接口必须都是抽象的没有具体的实现接口的概念就是描述数据的结构或者形状的定义好结构在去针对结构来进行实现和区别一般情况下描述对象类我门采用更多一些无法声明联合类型可以快速声明类型联合类型工具类型只能采用不能重名用的更多能用就不能用复杂类型采用接口可以描述对象结构子可以赋予给父类型不是具体实现子可以赋予给父亲我们需要把一个值赋予给另一个值如果是声明的必须必须一致地址赋值的时候会产生兼容性儿子可以赋予给父亲接口可以描述函数标识此值不能修改可以修改的如果给函数增加类型定义函数不能被修改时只能用可以通过表示接口的属性可有可无断言的方式来进行赋值用的最多接口的合并同名的会进行合并自定义类型的时候会使用自己的业务逻辑用的比较少可以扩展一个新类型在来使用可以扩展属性任意类型随机的属性描述数字索引的除了必有的属性之外其他任意兼容性只读属性红色任意接口随意值随意西红柿甜红色索引接口通过索引访问符来获取内部类型可以用于取值的类型取值的类型可以采用这种方式接口可以实现接口的实现都是通过类来实现接口中一个类可以实现多个接口一个接口可以继承多个接口接口可以用于继承类实现的是原型方法实现的是实例方法我门如何表示我要传入的是一个类类类型不能藐视类本身描述的是实例类的类型需要通过来取类型的校验规则鸭子类型检测描述构造函数泛型泛型坑位函数的形式参数刚开始类型不确定通过使用的时候来确定类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-05 18:06:40',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/custom/css/elementUI.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/custom/css/aurora.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Tom" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Tom</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/collect/"><i class="anzhiyufont anzhiyu-icon-book-open faa-tada" style="font-size: 0.9em;"></i><span> 藏宝阁</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AJAX/" style="font-size: 1.05rem;">AJAX<sup>1</sup></a><a href="/tags/AXIOS/" style="font-size: 1.05rem;">AXIOS<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>3</sup></a><a href="/tags/CSS3/" style="font-size: 1.05rem;">CSS3<sup>1</sup></a><a href="/tags/DOS-%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">DOS 命令<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>4</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>3</sup></a><a href="/tags/HTML5/" style="font-size: 1.05rem;">HTML5<sup>1</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/Javascript/" style="font-size: 1.05rem;">Javascript<sup>1</sup></a><a href="/tags/Less/" style="font-size: 1.05rem;">Less<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem;">Markdown<sup>1</sup></a><a href="/tags/Mobile-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">Mobile(移动端开发)<sup>1</sup></a><a href="/tags/NPM/" style="font-size: 1.05rem;">NPM<sup>1</sup></a><a href="/tags/Sass/" style="font-size: 1.05rem;">Sass<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>4</sup></a><a href="/tags/VUE/" style="font-size: 1.05rem;">VUE<sup>1</sup></a><a href="/tags/Vuex/" style="font-size: 1.05rem;">Vuex<sup>1</sup></a><a href="/tags/WebSocket/" style="font-size: 1.05rem;">WebSocket<sup>1</sup></a><a href="/tags/Webpack/" style="font-size: 1.05rem;">Webpack<sup>2</sup></a><a href="/tags/brew/" style="font-size: 1.05rem;">brew<sup>1</sup></a><a href="/tags/eggjs/" style="font-size: 1.05rem;">eggjs<sup>1</sup></a><a href="/tags/jquery/" style="font-size: 1.05rem;">jquery<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/node/" style="font-size: 1.05rem;">node<sup>1</sup></a><a href="/tags/nvm/" style="font-size: 1.05rem;">nvm<sup>1</sup></a><a href="/tags/react/" style="font-size: 1.05rem;">react<sup>1</sup></a><a href="/tags/vue-i18n/" style="font-size: 1.05rem;">vue-i18n<sup>1</sup></a><a href="/tags/yarn/" style="font-size: 1.05rem;">yarn<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>25</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">前端框架<sup>2</sup></a><a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">包管理工具<sup>1</sup></a><a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">命令<sup>1</sup></a><a href="/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/" style="font-size: 1.05rem;">外挂标签<sup>1</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">微信小程序开发<sup>1</sup></a><a href="/tags/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/" style="font-size: 1.05rem;">知其所以然<sup>3</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>3</sup></a><a href="/tags/%E7%BB%83%E4%B9%A0/" style="font-size: 1.05rem;">练习<sup>6</sup></a><a href="/tags/%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%99%A8/" style="font-size: 1.05rem;">静态模块打包器<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">23</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>前端</span></a><a class="article-meta__tags" href="/tags/TypeScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>TypeScript</span></a><a class="article-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>笔记</span></a><a class="article-meta__tags" href="/tags/%E7%BB%83%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>练习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">TypeScript笔记（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-28T03:14:53.000Z" title="发表于 2023-10-28 11:14:53">2023-10-28</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-07-05T10:06:40.225Z" title="更新于 2024-07-05 18:06:40">2024-07-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">26.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="TypeScript笔记（一）"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为广州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://mypic-ezp.pages.dev/img/img33.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://tom9527c.github.io/posts/9d362be7.html"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url">前端</a><a href="/tags/TypeScript/" tabindex="-1" itemprop="url">TypeScript</a><a href="/tags/%E7%AC%94%E8%AE%B0/" tabindex="-1" itemprop="url">笔记</a><a href="/tags/%E7%BB%83%E4%B9%A0/" tabindex="-1" itemprop="url">练习</a><h1 id="CrawlerTitle" itemprop="name headline">TypeScript笔记（一）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Tom</span><time itemprop="dateCreated datePublished" datetime="2023-10-28T03:14:53.000Z" title="发表于 2023-10-28 11:14:53">2023-10-28</time><time itemprop="dateCreated datePublished" datetime="2024-07-05T10:06:40.225Z" title="更新于 2024-07-05 18:06:40">2024-07-05</time></header><h1 id="1-TypeScript的环境搭"><a href="#1-TypeScript的环境搭" class="headerlink" title="1.TypeScript的环境搭"></a>1.TypeScript的环境搭</h1><h2 id="一-什么是TypeScript"><a href="#一-什么是TypeScript" class="headerlink" title="一.什么是TypeScript"></a>一.什么是TypeScript</h2><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDABQODxIPDRQSEBIXFRQYHjIhHhwcHj0sLiQySUBMS0dARkVQWnNiUFVtVkVGZIhlbXd7gYKBTmCNl4x9lnN+gXz/2wBDARUXFx4aHjshITt8U0ZTfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHz/wAARCAGQAZADASIAAhEBAxEB/8QAGgABAAIDAQAAAAAAAAAAAAAAAAQFAgMGAf/EAD8QAAICAQIDAwoEBQIGAwEAAAECAAMRBCEFEjFBUXETIjJhgZGhscHRFCNScjNCYuHwFfEGJDRDgpJTY7Ki/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AOziIgIiICIiAiIgIiICIiAiIgIiICIiAiRbtfpafTuXI7BufhIVvHKxtXUzeskKPrAt4nO2ca1LegEQeoZPxkd+Iat/Svcft835QOqmJIAySB4zkWutb0rXb9zEzAjJz2wOvNtY9KxR4kQLaz6NinwInIRA7EEEZBB8JlOMAwc9szW61fRtdf2sRA7CJyqcQ1aeje5/d53zkivjWpX0wjj1jB+EDoolRVxys7WVMvrBDD6SbTr9Ld6Fy5PYdj8YEqIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIkbU62jSj81vO7FG5MCTI+o1dGnH51ig9g6k+yUmp4vqLsir8pfV6R9v2kAkkkkkk9ST1gW+o44TkaerH9T/AGH3lbfq9RqM+VtZh3ZwPcNppkZtdpUYq9yhgcEdxgSYmmrV0XNy1WqzYzgTdAREQERI9+t0+nblutCt3YJPwgSImFV1d6c9Thh0yJnAREwa6tblqZwLGGQvaR/ggZxExd1rUs7BQOpJwBAyieKwZQykMpGQRvmewN1Gr1Gnx5K1lHdnI9x2llp+OEYGoqz/AFJ9j95TxA6vT6ujUD8mxSe0dCPZJE40EgggkEdCD0k/TcX1FOBb+avr9Ie37wOjiRtNraNUPym87tU7ESTAREQEREBERAREQEREBERAREQEREBERAREQEREBNdtqUoXsYKo6kmRtbxCrSLg+dYRsgPz7pz+p1Nuqs5rWz3KOi+AgT9Zxl3ymmBRf1nqfDulWzFmLMSzHcknJM8iAiIgJV8Y09S6RrVrVXLAlgNznrLSROJ6ezU6Q11AFuYHc4gRbh+D0VOp0yIrBV5zgZII+832amx+IU00EchXnc4zt/nzm2yoHQeStZV/LCkk7A4kPglRZX1D7k4RT6gP9vdAV363UajU11WIq1uQCygkbkAfCY/6rYmjcuAb1fk9Xbv8DMNMdSus1p0qox8oQwbxODNn+lO+jZXceXZufPZnu+JgeV6+6m6oW6iq9LDhguMr7pi6PpNZfZbpDejnIYDOBN1Wm1L2obatPSinJKopLfPEyenXae+x9MwtRznldunxga9HfpK/xF9HOrBeZqmwBt3e35xXZxKypdQjI6k5FfKOnj/eZVcPtue63VlQ9q8oC9nr+Exr0/EVqXTKyIin+IDviBnq9Vql1tVFAANleeVsbHft9WJiGsXiulruKNYajzMFGc+d0OJvfS2HidF4wa0TlJJ3zhvvPbdNY3FadQoHk1Qg775877wItN2u1VuoSq1FFbEAkDPU4Hwmq/U3avhVpdgprYBxjruMeG8aQ6pbtWdIEfNhDBvE4IkhOHWpw26nINtpBO+2QQcfCBK4eHGiq8owbKgrgYwMDAkmR9Ctq6VUvUKygKADnIA2kiAiIgIiIHqsVYMpKsNwQcES00fGXTCakF1/WOo8e+VUQOvqtS5A9bBlPQgzZOS02pt0tnNU2O9T0bxE6DRcQq1a4Hm2AboT8u+BNiIgIiICIiAiIgIiICIiAiIgIiICIiAlTxHioqJq05DWdC3UL4euaeJ8UJJo0x26M4+Q+8qIHrMzMWZizE5JJyTPIiAiIgIiICIiBrupr1Ffk7l5lznGSPlMq61qrCVgKo2AEW2CmprGBIUZ2moaoLyh1xzMFVlPMpz6/ZAyq09dL2PWuDYcsck5P+GbZqOppAYm1QF67+vHzni6iti2WC8pI37QADn4wN0TFbFdWashiNsZxvNdV5c+coUFio87OSP9jA3RNS6ipm5VsUtnHtni6mpgvnKGYZxn6wN0TUt9bcoLKGYA4z6swuoqZSy2KVA5ifVAVaeugual5S5ydycmbZr8vVzFedcjOd+mOsyrtS3PIwbl6+qBlERAREQEREBERAT1WZWDKxVgcgg4InkQL3h3FRaRVqCFs6Bugbx9ctpxkt+GcUIIo1J26K5+R+8C8iIgIiICIiAiIgIiICIiAiIgJR8V4kSTp9OdujsD8BN3FuIeSBopP5hHnMD6I7vGUUBERAREQEREBERAREQMbFZkZVYqx6N3SONKefn5lVuZThVwNs+vrvJUQIY0Tc6s1obGN+U5OGDd/qmT6IM1rCwqbM823ZgY7ewj4mSogaaKTVzFm5mY57T8yTMLaWFDKhJZn5lOPRJbPukmIERNKwdlBC1BlI2yTygdviIXRMpULYAAACQME49uD7ZLiBDXRcpA8oSo5SevUADpnHZ3TJtIxQKtgANYrYlc9O0byVECLbpeapl5ifOZsAbnmB2+My0y2c9r2jBYjG2Og7sn5yREBERAREQEREBERAREQEREC34VxIgjT6g7dEYn4GXk4yXvCeIG0Ci45sA81j/MO7xgW0REBERAREQEREBERASFxHWjSUZXBsbZR9ZJusWmtrHOFUZJnLarUNqrzY+2dlXuHYIGpmZmLMSWY5JPaZ5EQEREBERAREQEREBERAREQERJNWh1F2CE5V/U2394EaJbVcIQb22Mx7l2El16PT1+jUue9hk/GBQKjP6Cs37VzNq6HUt6NLe3b5zoQMDAiBRDhupPVFHiwmf+lan+j/2/tLqIFIeF6kdinwaYNw7VL/2s+DD7y+iBzjaa9PSqcDv5SRNR2OO0TqJi9aWDDorD+oZgczEvbeG6Z+ilD3qfp0kO7hNi71OrjubYwK6JnbTZS3LajKfX2zCAiIgIiICIiAnqsysGUkMpyCOwzyIHTcO1o1dGWwLF2YfWTZyWl1DaW4WJvjZh3jtE6mmxbq1sQ5VhkGBsiIgIiICIiAiJG12oGl0zWbZ6KO8mBVca1nPYNOh81d29Z7vZKqesSzFmJLE5JPaZ5AREQEREBERAREQEREBESRptHbqjlRyp2sen94EfGTgbkydp+GW24a0+TXu/mP2llptHVphlV5m7Wbr/AGkiBoo0lOnwUQc36m3M3xEBERAREQEREBERAREQEREDxlVlKsAwPUEZkG/hdT5akmtu7qsnxA52/S26c4sXA7GG4PtmmdOyhlKsAQeoIzK7VcLVstp/NP6T0PhAqYmTKyMVZSrDqCJjAREQEREBLXgus5LDp3PmtuvqPd7ZVT1SVYMpIYHII7DA7KJG0OoGq0y27Z6MO4iSYCIiAiIgJznGdT5bVeSU5WrbxPb9pd6y8abTWW7ZUbA9p7JypJJJJJJ3J74HkREBERAREQEREBERARABJAAJJ2AHbLnQcPFPLbcAbOoXsX+8DRouGlsWagEL1CdCfH7S1VQqhVAAGwA2xPYgIiICadUSNJcQcEI3ym6adUCdJcAMko3ygcRw0aC7Sh9dxXUU3ZIKhiRjs7DLbiTNov8AhhTw3U231vZ51rHzgpznfs3AEg8I12n0WhFOr4VbdYGJ5vIhtj4y4t1+pu4P5fhWj5eRyrUWV7lcb4UH1/OBVU6HQOEs4PxU160Efxn5ebvGMZ9m8t+IcPtIt1t3FdTplVAzpU5CqQoB5d+0j4yk19+g4jT5LR8Hur1rEYwgABzv06+0Sx41VqTwzhnDW5me1lW1lGemBufEj3QJP/DFWrOmfVarUXWrcfy1tcsQozvv3y8mKKtaKiqFVQFUDsAmUBERAREQEREBERAREQNOp0tWqXDjDDow6iUep0tmlflcZU+iw6GdFMba0uQpYoZT1BgczEla3RtpWyMtWx81u71GRYCIiAiIgWHBtT5HVeSY4W3bwPZ9p0c40EgggkEbg906rR3jU6au3tYbgdh7YEiIiAiJ5ApePX5augHYec3yH1lPN2ru/Eau23OQzeb4DYfCaYCIiAiIgIiICIiAiJacL0fo6i0fsU/OBt4foRSBbaM2noP0/wB5PiICIiAiaNbqfwmla7CtylRhm5RuwG5wcdZHXiDPyrWunssduVfJ3cyjAJJY8ox9YE+JAs19mntpq1FAXylhQsr5UDAww27yB2Yg8TXm1irVzfhyqqeb+IzEgDpt5w5YE+JAs4kFo09gCILgcm1uVUI6qTjrnb2GbF19QVPLZR2AJVQWC5OASwGACRsTjMCXEgjiumIDh/yiMhirAk8yqMDl3GWAznr7cbK9fVbqa6KwzF1Y5KsOUqVBByNj53b6u8QJUSFqNf8AhrT5WorTzcvOTuTy8xIXtG3XPftjeeDiJFdrW0MrJWtoVTzEqc49uxz3d8CdEgW8TVGqUKpZkVypsCnDHAC59I7HbbpJ8BERAREQEREBERAREQMXRbEKuoZWGCDKPW6RtLZtk1t6LfQy+mF1S3VtW4yrQOaibtTp201pRtx1Vu8TTAREQEuOA34aygnY+cvyP0lPN2ku/D6uq3OAred4HY/CB1sREBIvEbfI6K5878uB4nb6yVKjj9vLTVUP5mLHwH+8CjiIgIiICIiAiIgIiZIrWOqKMsxwBAkcP0v4m3LD8td29fql9NWmpXT0rWvZ1Pee+bYCIiAiIgadVR+JoarmKklWDYzgggj5TU+mtflZtQPK1tzIwTAG2CCM7g57x2SXECDZw7ywJuuZnbmyQMAcyhfNHZjA9u8xXhNXMvO7Oo5SykemVDbn2tzeIEsIgQl0LU/9Laa1DMwRl5lw2CQRkZ3BIOdsmY0cNOmP5F5QNjynmjfzmbzexfSI6Hb3yfECs1HDGGnpWhyXp5FUkDoLFYt7AvSb6dD5LULebS1nn82FwG5uXoOzHKsmRAhNoC+otse0MtoKkMuSqkYKqc7CZV6EqtvlbTYz1ioNjGFGce3c5PwkuIEC7hosUqtvKr1LTZlcllGcY7jud9+snxEBERAREQEREBERAREQERECPrdKuqpK7Bl3U9xlAylWKsCGBwQeydPKri2lwRqFGx2b6GBWREQEREDqeHW+W0VL535cHxG30kqVHALeam2o/wArBh4H/aW8BOd45Zza1V7FUD2nJ+06KctxJufX3N/Vy+7b6QIsREBERAREQEREBLPhGnyW1DD+lfqfp75XIjWOqL6THAnSVVrTUta+ioxAyiIgIiICIiAmm/UpQyKwZmfPKqqWJx16TO6s21lVsesn+ZMZHvBmjU1WnUae2lVfyXNzBm5c5GO6BupvrurDo2xJHnDlII2IIO4Mz5hzcuRnriU2o4XqLiznlJtD8yBlwrNgDdlPYBkgAzKzh1xW1ORHsYsRqGbDMCuADjf1d2BnwC35lwDzDB6bzG26qlC9jqqghSc9CTgfOVtXDmbWLc9NSVK5YVbHlPKADjpnI+AkZeFakhueqrLIoIyoUsrhjjC5wd8Zye+Be8y77jbrv0gMpOAwJxnGZTWcLusRk5K1I5w1md7eZgRnt6Dt7cYm9NA9XEhbVUi0hubswBy8u22Qc9meXHrgWcREBERAREQEREBERAREQEREBERATF0WxGRhlWGCJlEDmrqWptatuqnr3iYS24xRlVvUbr5reHZ/nrlTAREQLHgdnLrWXsZSPaMH7zopy3DW5NfS39XL79vrOpgJx9zc19jfqZm95nXMcAk9gzOOGSN+sBERAREQEREBERAsOEU817WkbIMDxP8Ab5y4kXhtXktGve3nH29PhiSoCIiAiIgIiIGF1yU1l7W5VHU4z8po1usXS1qxUNzZxlgvQZ7evskqab9LVqGVrA2VyAVYqcHqNuyBEXiy2Ny10sxZOZVZgrN5vMMA9R2ZGd5l/qa2Wqmnqa7m9FuYAHzQ3b6iPfNlfDqKSrVKwKYKqzMVDBeUHGeuNp7pNDVpqqlwGasswYZG7ddu7sHcMQMNNxEankaml2qIXmbIHKWUMNvBhnxmpeKBGqWxc+WZeUhgCFZsL5vXpjP1m8cN0oCqqMqKoXlDsAcLygnfcgbZ67DuE9s0Gnts52VgcqcKxUZU5U4BxtA008WrusWsVMGblGCR6R3Yf+I3M1pxZbXVEQhiy4wysCGyMEjYHbeTF0OmWwWLUAwZmzk9W9I+2YVcN01TKyq5KBQvM7NgL6PU9mYGfD731OiputVVd15iF6SRMKaUoqWqpSqL0GSce+ZwEREBERAREQEREBERAREQEREBERAwurW6pq26MMTm2UqxVhhlOD4zp5R8Uq8nrCwHmuA3t6GBDiIgZ0ty31t+llb3GdhOMOQNus7EEEAjt3gY2nFTt3KT8JyE6+0Zqde9SPhOQgIiICIiAiIgJlWhssVB1ZgvvmMlcNTn1qdy5Y+7+8C9UBVCgYAGBPYiAiIgIiICIiAiIgIiICIiAiIgImJc83IgLP3Ds8T2TYunzvcec/pHoj2dvtgaw/McVhrD/T09/SZim4+kyoO5Rk+/b5SSAAMDYCewI40y/wAzOx7+bHyxMvw1ON61P7hn5zdEDV+Hp7aq/wD1E8Onq7EA/aSvym6IEb8Nj0HdfVnmHx3mJruXsWwf07H3Hb4yXECEHGcHKt3EYP8AeZSQ6LYpV1DKewiR3oevesl1/Sx39h+/vEBExVw2RuGHVSMETKAiIgIiICV3GK+alLB1Vsew/wCwljNGuTn0dy9y83u3+kDnoiICdfUc1I3eoPwnITr6hipF7lA+EDJhkEHtGJxwyBv1nZzj7l5b7F/SzL7jAwiIgIiICIiAljwZc3WN+lQPef7SultwZfMubvIH+e+BZREQEREBERAREQEREBERAREQExUNcxCHCDYv9BAU3MVBIQbMw2z6h9T/AIJaqFAVQAAMADsgeV1rUvKgwPnM4iAmp9RTWeWy2tW7mYAzbOQ4np31H/FF6poK9aRp1PI78oXfrmB1Quqas2CxCg6sGGB7YpvqvUtTalgG2VYMPhOd13DrH4PpqK9Np9K/4gO2kNoAtx/LntJ2kQW16K/VMuhu4ZrDpHK1qymp8Anm2HUddu73h1yWIzMiuCy9QDkjxmycdwVU0eo4W1+hWo6hD5O6uwlmJUE847c5yO6djAREQEREDTbSLMHdWHRh1H9vVNAJDclgAbqCOhHePtJs12VrYuG8QR1B7xA0RMVLBjXZjmG+R0I7x/m0ygIiICeMoZSp6EYM9iBy+CNj1ETZqF5dRavc7D4zXAHJG3WdiAAAB2bTkaV5r61/Uyr7zOwgJy3El5Nfcv8AVze/f6zqZzvHK+XWq3Yyg+0ZH2gV0REBERAREQEuODj/AJdz/Xj4CU8uODn/AJdx28/0ECwiIgIiICIiAiIgIiICIiAmLEswRDhj29w7TPSQqksQANyZs0ykKbGBDPvg9g7B/naTA2oi1oFUYA6TOJE4hqTpNKbRy550XLdBzMFyfDOYEuJWLrbXauqqyiyywthgDyqABkkZ3O42yOs8s19+m1Glp1FSgWMVaxT2eaAQOzLMBgwLSVWs4Fp9ZrG1TXamq1lCk1WcuQPZPP8AVHcazydSk1WLVTk+mxPLv6ubPs3ntnEXNOmsULUlylnd0LLWRjzTjGDkncnHmmB4eA6V9GdNbZfaBZ5RbHsJdDgDY9nSNJwLTUWtbbbqNXYyFObUWc5CnqBN1PEEcVBgSzBSxr89V5jgbjsPy3OJhXxjTuosAfybKjLms8zczYGB3Zga9JwHTaTUV2rZfZ5IEVJZZzLVnryjHzlvIFPEFv1iUJW2GRmZjtylWAKke35TVqeJNprG8tSFr88jD5bCqSWK42Bxjr2jvgWkSrs4hdTVqTbps3UVi0ojggqc43OOhU58MjriZW8Q5NVXTyqqlUYu3NjziRjIGAdu0jOYFlERAREQNN1XlF2OGG6nuP2mhW5lzggjYg9h7pNkS9eS0WD0W2b1HsP090BERAREQOd1gxq7v3GaZu1hzq7v3GaYErhq8+vpX+rm92/0nUzneB182tZuxVJ9pwPvOigJUcfq5qarR/KxU+B/2lvIvEavLaK5Mb8uR4jf6QOWiIgIiICIiAltwY/l2r3MD/nulTLLgzYttX9Sg+7/AHgW0REBERAREQEREBERAREQMSPKWJX2E5PgP74EmyNphl7LPWFHgP7k+6SYCR9VQNVT5NmZPOVwy4yCrBh1BHUCSIgQX0TNys2qtNiHKOQuVyMEYAAIPrmDcLqfJsssZ2DBnyMktgZ6bEcoxjpiWMQK4cI0wZOYNYi8vmPggkKVBIxvsT7d56vDkqK/hrbKeVmKqvLygMQSMEYxkZHaPDaWEQK+nhq6ds03WopwXAI88gk5JxtnO+MTVbwkCmhNPY6mpaqwTjIVGznp1+EtYgQaNAlNwuFjmwc3MdvP5iCc7eoYxieDhqF7y9trrqMixCFwwIIxnGcAHbeT4gQV0I8netttljXp5NnOOYKAQAMDHaT4kxdofKnBus8mQoavIw3KcjsyM9uJOiAiIgIiICYWILK2RujDG0ziBCRiy79R5reI2Myhxy6hu5wGHiNj9IgIieEhQSeg3gc5qDzai497t85rgksSx6neIF5wCrlpttP8zBR4D/eW8i8Oq8joqUxvy5Pid/rJUBERA5LV0/h9XbVjAVvN8DuPhNMuOPUYau8DY+a3zH1lPAREQEREBJfC35dao/UCv1+kiTKp/JWo/wClg3ugdNEA5GRuIgIiICIiAiIgIiICImN38J8deU/KBv0wxp07yOY+J3Pzm6eAAAAdBPYCImm+lb05HLgdcpYyH3qQYGq/V1aexUuJUNW1nMegClQfXnLDExr4hU3P5UGjkVWbypC4znHb12mGs4cmt1NVl2CldbqB2gkqQwPYRyn4TQ+g1TZsa1HsbyYbqnMF5t8gEqTkHbpvAn/i9PzVgaiomwZQc4y3hvvA1mmKuw1FRFfpkOML477Srp4RfUawHrADDmYMxyA5bBByDscb7g75M8XhOoCqPKKoq5ORVdsHGe0jKjB2AyARAtG1ulXlzqaRz45cuPOycDG++8kymThD+R1Cmxea2op2tglmY7nr6UuYCIiAiIgIiICIiAiIgR9SMNWw7yp8CPuBMJt1X8H/AMl//QmqAmnWvyaO5uh5SB4nb6zdIHGLOXTqnazfAf3xAppu0lP4jV1VYyGbzvAbn4TTLjgNGWsvI2Hmr8z9IF3ERAREQI+soGp01lXaw2J7D2TlSCCQQQRsR3TspznGdN5HVeVUYW3fwPb94FfERAREQEREC/4fb5XSIT1Ucp9kkyp4Pdy2PUTsw5h4jr/nqltAREQEREBERAREQExt/hP+0zKYW/wX/aflAnRPOs9gJpvuFNfOVsffGEUsfcJuiBWa/U26fiOjCtijlc3DA3HMig+rBbPhmRtFxHU3X2IAHaywtSHPKFr5VI6AnOGHvPdLa2iq8nytavlCh5hnzWxkeBwPdMH0ensHnVL1DZAwcgY6j1beECufil2oprs06BENmnDktuOdlyAMYIwcZz2numVvFHenSlF5Gu8k5IOcA2opHtDGTjotMXRjSmV5QPN2GDldvV2d08TQaVG5loQHII26YIIx7QD4wI+g4kdZaqihkSys2o2GG2RscqBncHYnt9tnI9WloocvVWqsdsgdncO4eEkQERI7alckIpsI2PL0HtgSIkXytp6BF9W7faeeVuHbWfVykfWBLiRxqeX+KhA713H3+E3KysoKkFT0IOcwMoiICIiBq1P8B/CaZs1R/J/8lHxE1wEpeK28+q5QdkXHtO5+kuLHWutnbZVBJnNuzO7O3pMSTA8AJIABJOwHfOq0dA02mrq7VG5Hae2UnBtN5bVeVYZWrfxPZ950cBERAREQEja7TjVaZqts9VPcRJMQONYFWKsCGBwQewzyWvGtHyWDUIPNbZvUe/2yqgIiICIiBlVY1Nq2L1U58Z0iMtiK6nKsMiczLbhGoyrUMd185fDtgWUREBERAREQEREBBGRgxEDbpzmivO5CgHxGxm6R9M2DZX3NkeB/vmSICIiAiIgIiICedJ7I2pPORUOhGW8O72/IGBrZjqCeoq7B2t4+r1TIAAAAYAiICIiAmODW3NVsTuy9jf39cyiBvrsFqBlz4HqD3GbJDRvJXBv5XPK3j2H6e6TICIiBG1R/hr3tkj1AH64mMWHm1J7kHL7TufhieMwVSzHCqMk90Cv4vdy1LUp3Y5PgP7/KVKgswVQSxOAB2mbNTcdRe1hzgnYdw7JYcF0fPYdQ481dl9Z7/ZAtdDpxpdMtW2erHvJkmIgIiICIiAiIga7q1uratxlWGCJy2q07aW41vvjdT3jsM62QuI6IaujC4Fi7qfpA5mJ6ysrFWBDKcEHsM8gIiICZVWNTati+kpyJjEDpabVuqWxfRYZ8JnKXhuq8jb5Nz+W5/wDUy6gIiICIiAiIgIiIHmfJ2o/YfNb29Pjj3mTJDZQylW6EYM26ewunK/prsfX6/bA3xEQEREBERASHnmtsbvblHgNvnmTJCXq372//AEYGUha7iui4e6rq7vJswyo5WOR7AZNnO8bNi8e0Jq1KaZ/JNiywAqOvfAtNPxjQami2+nUA1U4LsVZeXPTqJ5o+M6DXXeSovzYRkKyleYd4yN5Xazkt4Lqa+IcTrvUsv5tKA8m4xkL6xNS6m6riOgTVvo9dzMVqtqGLFyOuBtiBbDjXDzqfww1Km7n8ny8p9LOMdMdZPnKafUX6CnTW6bX1amq7U8rUrWATzEknPpZ/tOrgY2LzIyg4JGx7jJSPz1qw2DAH3yPN2m/6ar9g+UDbMHcIpZjhQMkzORdQ3Oy1DoMM3h2D3/KBrrDcpLDDMeZvUT2ezpIHFtThRp1O7bt4dgkzVahdNSztueijvM58l7rSTlnZveTA2aXTtqrhWm2d2PcO0zqaa1prWtBhVGAJG4dohpKMNg2Nux+kmwEREBERAREQEREBERAqeLcPNoN9IzYB5yj+Yd/jKKdnKPivDSCdRpxt1dQPiIFRERAREQEuOGazyiimxvPUeaT/ADD7ynnqsVYMpIIOQR2QOniRNBrRqU5WwLVG4/V6xJcBERAREQEREBMSTW4tUE42YDtH3H375lECSrBgGUggjII7ZlIaP5BiD/DY5P8AQft8pLgexEQEREBIbDlvsXvww9u3zB98mSPqK2K86DLLuB3jtH+dwgYSPqdDpdWytqdPXcyjALLnE3qwZQynIM9gRquH6OhLEp01SrYAHUKMMB3jt6meabhmi0lps0+mqrc7cyruPCSogRU4do01B1CaaoW5zzBRnPf4yVEQMbSeQgbE+avidhJYUKAAMADAkahfKWc/8q5C+s9Cfp75Id1rQs5wogY22ipMkZJ2Ve0nukbIqRntYZ6sYLFibbfNAGwP8o9frlNr9adS3KhIqX/+j3wNWs1Taq0schV2Ve4S24Tw81AX3DFhHmqf5R3+M08K4aSRqNQNuqKR8TLyAiIgIiICIiAiIgIiICIiAiIgUfE+FkE36YbdWQfMfaVE7OVPEeFC0m3TgLZ1K9A3h64FFE9ZWVirKVYHBBGCJ5AREQMlZkZWVirKcgiXWi1y6kBXwto6jsb1iUc9BKkFSQRuCD0gdPErdFxINivUEK3QN2Hx7pZQEREBERAREQExR2oPQtX3Dcr4d49XZMogSVYOoZSCDuCDkGZSFhkYtWcE7lT6LfY+v5zbXqFYhXyjnYBu3wPb84EiIiAiIgRraSrF6gN92Xv9Y9c1q6sSOhHUHYj2SbNb1pYAHUHHTI6eEDREzOmGPNssX1ZB+YM9/Df/AG2H3faBqZlUZZgB6zC1vaQSClfr2ZvsPjNy011+dyjmH8xOSPaZrfUc21I5v6j6I+/s98Da9iUoM7DoFA3PqAkV2LHytxCqu4BOy+s+v/PHG22uhTbc+WO2T1PqAlPqdXbrHCqpC581F3z495gZ6/XHUnkTK1D2c3jJXDOFkkX6kbdVQ/M/abuHcKFWLdSAbBuq9Qvj3mW0BERAREQEREBERAREQEREBERAREQERECFreH1atcnzbANnA+ffOf1Omt0tnLauO5h0bwM62a7akuQpYoZT1BEDkIlrrODOmX0xLr+g9R4d8q2UqxVgVYbEEYIgeREQEl6TX2afCtl6/0nqPCRIgdHRqKtQvNUwPeOhHsm2cyrMjBlYqw6EHEsNNxZlwuoXmH6lG/tEC2ia6rqrl5qnVh24O48RNkBERAREQE8ZVZSrAEHqCMz2IGI50/huQO5vOH3+M2DUMB59Z8VOR9JjEDYNTV2uF/cCvzmxXVvRYHwOZHmLVoxyyq3iMwJs1tbWnpOq+LASL5Gr/40/wDUT1VVfRUL4DEDcdTWD5pLftBI9/SYG+xvQQKO9jk+4feeSLqOIUU5Abnb9K7+8wN5TnObWL+o9B7OkiariVdOVpxY/f8AyiV9+tv1TcoyqtsEXt+pkvR8GZ8PqSUX9AO58e6BDrq1HEbzjLN2sfRUS90XD6tIuR51hG7kfLukmqpKUCVqFUdABNkBERAREQEREBERAREQEREBERAREQEREBERAREQEjanRUaofmr53Yw2IkmIHOanhGopyavzV9XpD2faQCCCQQQR1BHSdlI+o0lGoH51ak9h6Ee2BykS41HAyMnT25/pf7j7Stv0mo0+fK1Mo78ZHvG0DTERA9VmVgykqw6EHBkynid9eA+LF/q2PvkKIF1VxSh9n5qz6xkfCS67q7Rmt1b9rAzmo7c9sDqInOpqr09G1x6i2fnNy8T1K9WVv3L9oF5Epl4td/MlZ8AR9Zl/q9v/AMSe8wLeJUHi9vZWnxmDcW1B6LWv/ifvAuolA3ENS3/dIH9IAmh7Hs9N2b9zZgX9mt01Wea1Se5fOPwkO3i46U1E/wBTHHwkCjSajUY8lUSO/GB7+kstPwMnB1FuP6U+5+0Cut1V+pPKzsQdgq7A+wdZJ03CL7sG38pPX6Xu+8u9PpKNOPya1B7T1J9skQI2m0VGlH5S+d2sdyZJiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIEW7QaW706Vye0bH4SFbwOs712svqIDD6S3iBztnBdSvoFHHqOD8ZHfh+rT0qHP7fO+U6qIHHtTavpVOv7lImBODjtnZzEgEYIB8YHHROvNVZ9KtT4gQKqx6NajwAgcgDk47ZmtNrejU7ftUmdcAFGAAB6plA5VOH6t/Rocfu835yRXwXUtu5RB6zk/CdFECoq4HWN7LWb1ABR9ZNp0Glp9ClcjtO5+MlRAREQEREBERAREQEREBERAREQEREBERA/9k=" alt="TypeScript"></p>
<p><code>TypeScript</code>是<code>Javascript</code>的超集，遵循最新的<code>ES5/ES6</code>规范。<code>Typescript</code>扩展了<code>Javascript</code>语法。</p>
<ul>
<li>Typescript更像后端JAVA,让<code>JS</code>可以开发大型企业应用</li>
<li>TS提供的类型系统可以帮助我们在写代码时提供丰富的语法提示</li>
<li>在编写代码时会对代码进行类型检查从而避免很多线上错误</li>
</ul>
<blockquote>
<p><code>TypeScript</code>不会取代<code>JS</code>, <strong>尤雨溪：</strong> 我认为将类型添加到<code>JS</code>本身是一个漫长的过程 。让委员会设计一个类型系统是（根据<code>TC39</code>的经历来判断）不切实际的 。</p>
</blockquote>
<h2 id="二-环境配置"><a href="#二-环境配置" class="headerlink" title="二.环境配置"></a>二.环境配置</h2><h3 id="1-全局编译TS文件"><a href="#1-全局编译TS文件" class="headerlink" title="1.全局编译TS文件"></a>1.全局编译TS文件</h3><p>全局安装<code>typescript</code>对<code>TS</code>进行编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br><span class="line">tsc --init <span class="comment"># 生成tsconfig.json</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="comment"># 可以将ts文件编译成js文件</span></span><br><span class="line">tsc --watch <span class="comment"># 监控ts文件变化生成js文件</span></span><br></pre></td></tr></table></figure>
<h3 id="2-配置-webpack-环境"><a href="#2-配置-webpack-环境" class="headerlink" title="2.配置 webpack 环境"></a>2.配置 <code>webpack</code> 环境</h3><ul>
<li><p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollup typescript rollup-plugin-typescript2 @rollup/plugin-node-resolve rollup-plugin-serve -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>TS</code>配置文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>webpack</code> 配置操作 </p>
<ul>
<li><code>rollup.config.js</code> 文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认rollup 打包的时候会查找当前目录下 rollup.config.js这个文件</span></span><br><span class="line"><span class="comment">// 采用es模块来编写配置文件</span></span><br><span class="line"><span class="comment">// node中有模块规范默认是 commonjs , 也可以改成esm模块规范</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ts <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; nodeResolve &#125; <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&quot;url&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前文件的绝对路径 file://xxxx/xxx/xxx</span></span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>); <span class="comment">// 当前文件的绝对路径</span></span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(__filename); <span class="comment">// 当前文件所在的文件夹目录 绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包的配置对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>, <span class="comment">// 项目入口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">file</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist/bundle.js&#x27;</span>), <span class="comment">// 当前的文件在当前目录下的dist目录</span></span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;iife&#x27;</span>, <span class="comment">// (function()&#123;&#125;)()</span></span><br><span class="line">        <span class="attr">sourcemap</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="title function_">nodeResolve</span>(&#123;</span><br><span class="line">            <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>]</span><br><span class="line">        &#125;), <span class="comment">// （第三方包的入口）入口文件可以是js 也可以是ts</span></span><br><span class="line">        <span class="title function_">ts</span>(&#123;</span><br><span class="line">            <span class="attr">tsconfig</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;tsconfig.json&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>package.json</code>配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rollup -c -w&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过<code>npm run start</code>启动服务来使用typescript啦~</p>
</blockquote>
<p><code>package.json</code>文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@rollup/plugin-node-resolve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^15.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^20.5.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rollup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.27.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rollup-plugin-typescript2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.35.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.6&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rollup -c -w&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@types/jquery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.5.17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.21&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mitt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reflect-metadata&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.13&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.3.4&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 我门在使用ts的时候 需要将编写的ts代码转换成js 在运行<br>typescript这个模块 来进行文件的编译<br>npm install typescript -g 全局的包只能在命令行中使用  tsc<br> 最终直接生成js 文件在运行。<br>tsc —init 初始化ts的配置文件<br>比较适合临时测试的方式<br>vscode插件来实现代码的运行<br>code-runner 如果是js文件 内部会直接采用 node + 文件名来执行此文件 ,如果是ts文件 需要通过ts-node     来直接执行<br>sudo npm install ts-node -g<br> 通过构建工具将代码转化成js 在去运行 （webpack,rollup,esbuild） 最终便衣成js执行</p>
</blockquote>
</li>
</ul>
<h1 id="2-基础类型"><a href="#2-基础类型" class="headerlink" title="2.基础类型"></a>2.基础类型</h1><p>TS中冒号后面的都为类型标识</p>
<h3 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型 boolean"></a>布尔类型 <code>boolean</code></h3><p>布尔值 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>; </span><br></pre></td></tr></table></figure>
<h3 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型 number"></a>数字类型 <code>number</code></h3><p>数字 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>; </span><br></pre></td></tr></table></figure>
<h3 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型 string"></a>字符串类型 <code>string</code></h3><p>字符串 JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用<code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（<code>``），并且以</code>${ expr }` 这种形式嵌入表达式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>
<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +<span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 <code>array</code></h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr4</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h3 id="元组类型-Tuple"><a href="#元组类型-Tuple" class="headerlink" title="元组类型 Tuple"></a>元组类型 <code>Tuple</code></h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个元组类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// 初始化错误</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>:[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>] = [<span class="string">&#x27;zf&#x27;</span>,<span class="number">10</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="comment">// 像元组中增加数据，只能增加元组中存放的类型</span></span><br><span class="line">tuple.<span class="title function_">push</span>(<span class="string">&#x27;回龙观&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当访问一个已知索引的元素，会得到正确的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27;没有中&#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当访问一个越界的元素，会使用联合类型替代</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 你赋予的值要求得符合这个结构和顺序, 元组在新增内容的时候 不能增加额外的类型的值，只能是已有的，而且增加后无法访问   </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>已经约定好没有第四个，后续增加的不算，访问的时候不能访问后增加，安全问题 </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">item</span>: <span class="built_in">string</span> = tuple[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-枚举类型-enum"><a href="#3-枚举类型-enum" class="headerlink" title="3.枚举类型 enum"></a>3.枚举类型 <code>enum</code></h3><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字    常用于 状态码 权限 数据格式 标志位</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="variable constant_">USER_ROLE</span> &#123;</span><br><span class="line">    <span class="variable constant_">USER</span>, <span class="comment">// 默认从0开始</span></span><br><span class="line">    <span class="variable constant_">ADMIN</span>,</span><br><span class="line">    <span class="variable constant_">MANAGER</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;0: &quot;USER&quot;, 1: &quot;ADMIN&quot;, 2: &quot;MANAGER&quot;, USER: 0, ADMIN: 1, MANAGER: 2&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 可以枚举，也可以反举</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后的结果</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">USER_ROLE</span>) &#123;</span><br><span class="line">    <span class="variable constant_">USER_ROLE</span>[<span class="variable constant_">USER_ROLE</span>[<span class="string">&quot;USER&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;USER&quot;</span>;</span><br><span class="line">    <span class="variable constant_">USER_ROLE</span>[<span class="variable constant_">USER_ROLE</span>[<span class="string">&quot;ADMIN&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;ADMIN&quot;</span>;</span><br><span class="line">    <span class="variable constant_">USER_ROLE</span>[<span class="variable constant_">USER_ROLE</span>[<span class="string">&quot;MANAGER&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;MANAGER&quot;</span>;</span><br><span class="line">&#125;)(<span class="variable constant_">USER_ROLE</span> || (<span class="variable constant_">USER_ROLE</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>异构枚举</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="variable constant_">USER_ROLE</span> &#123;</span><br><span class="line">    <span class="variable constant_">USER</span> = <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    <span class="variable constant_">ADMIN</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="variable constant_">MANAGER</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量枚举</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">USER_ROLE</span> &#123;</span><br><span class="line">    <span class="variable constant_">USER</span>,</span><br><span class="line">    <span class="variable constant_">ADMIN</span>,</span><br><span class="line">    <span class="variable constant_">MANAGER</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">USER_ROLE</span>.<span class="property">USER</span>)<span class="comment">// console.log(0 /* USER */);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="任意值-any"><a href="#任意值-any" class="headerlink" title="任意值 any"></a>任意值 <code>any</code></h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：</p>
<blockquote>
<p>any 任何类型 能不写any 就不要用any ， any会导致类型丧失检测  anyScript(如果我们的项目是采用ts编写的，一般情况下any的出现场景不多) 放弃检测，出错就怨自己。 没有ts的加持</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;这是是字符串&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// 可以的，肯定是布尔值</span></span><br></pre></td></tr></table></figure>
<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// ifItExists可能在运行时存在</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// 好的，toFixed存在(但编译器不检查)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// 错误:属性&#x27;toFixed&#x27;在类型&#x27;Object&#x27;上不存在.</span></span><br></pre></td></tr></table></figure>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span> = [<span class="string">&#x27;jiagou&#x27;</span>,<span class="literal">true</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;zf&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="空值-void"><a href="#空值-void" class="headerlink" title="空值 void"></a>空值 <code>void</code></h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：</p>
<p>只能接受<code>null</code>，<code>undefined</code>。一般用于函数的返回值</p>
<blockquote>
<p>严格模式下不能将<code>null</code>赋予给void</p>
<p>void 类型代表的是空类型    undefiend   void  这个void一般值表示函数的返回值</p>
<p>unefiend 可以赋予给void， 都代表空 (undefiend 是 void的子类型)</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;这是我的警告信息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">void</span>;</span><br><span class="line">a = <span class="literal">undefined</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和<code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="comment">// 我们不能给这些变量赋多少别的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">name = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<blockquote>
<p>如果禁用非严格null检测，null和undefiend 可以赋予给任何类型 （null,undefiend任何类型的子类型）</p>
<p> 如果<code>strictNullChecks</code>的值为true，则不能把null 和 undefined付给其他类型</p>
</blockquote>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免<em>很多</em>常见的问题。 也许在某处你想传入一个<code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>
<blockquote>
<p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p>
</blockquote>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；</p>
<blockquote>
<p>never代表不会出现的值。不能把其他类型赋值给never</p>
</blockquote>
<p>然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  never 永远不，永远达到不了的地方就是never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;err&quot;</span>); <span class="comment">// 出错函数无法执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数无法执行完毕</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125; <span class="comment">// 函数无法达到执行完毕的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果if/else 条件都走完了， 没有遗漏的 后面的类型就是never (完整性保护)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">number</span> | <span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x == <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// never</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>   never类型 只能被never类型来赋予值</p>
</blockquote>
<h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><p>Symbol表示独一无二</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 == s2); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">symbol</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br></pre></td></tr></table></figure>
<h3 id="BigInt类型"><a href="#BigInt类型" class="headerlink" title="BigInt类型"></a><code>BigInt</code>类型</h3><blockquote>
<p><code>number</code>类型和<code>bigInt</code>类型是不兼容的</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> num2 = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> + <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 == num2)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">max</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max + <span class="title class_">BigInt</span>(<span class="number">1</span>) === max + <span class="title class_">BigInt</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h3 id="object对象类型"><a href="#object对象类型" class="headerlink" title="object对象类型"></a><code>object</code>对象类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> create = (<span class="attr">obj</span>:<span class="built_in">object</span>):<span class="function"><span class="params">void</span>=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">create</span>([]);</span><br><span class="line"><span class="title function_">create</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>练习代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts关注的是类型，不是业务逻辑） </span></span><br><span class="line"><span class="comment">// 类型的分类： 基础类型、高级类型、内置类型、自定义类型、类型体操</span></span><br><span class="line"><span class="comment">// TS的类型都是在变量后面来写 ：后面是类型 = 后面是值 (ts语法，不是js对象)</span></span><br><span class="line"><span class="comment">// ts的特点，如何来学习？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1).ts的目的是什么？从安全角度来考虑使用 (考虑我在赋予结果的时候 是否会发生错误)  error lens</span></span><br><span class="line"><span class="comment">// 2).ts是用来检测类型的，只是提示作用，不是在运行的时候发生的 (运行的时候和ts无关，“代码没有被执行”)</span></span><br><span class="line"><span class="comment">// 3).编译ts之后 类型就消失了，不存在类型了（写的都是空气） 最终生生产环境下 可以增添.d.ts 来对js文件增加类型声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ts的特点：在编写代码的时候 并不是所有的变量都要添加类型。 （ts中支持类型推导，根据赋的值来猜测他的类型） 如果猜测的类型是对的不用给类型, 如果猜测的不对，或者类型无法正确的推导 自己写类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1） string number boolean</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;jw&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">gender</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础类型， 包装类型  规范 小写的类型一般用于描述基本类型 大写的用来描述的是实例类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s1</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">// let s2:string = new String(&#x27;abc&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s3</span>: <span class="title class_">String</span> = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 在赋予值的时候 子集可以赋予给父级</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s4</span>: <span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 类的类型，类类型，用来描述实例的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用基本类型的时候 需要采用的时候 小写类型来标识</span></span><br><span class="line"><span class="comment">// 数组的概念：用于存储多个类型相同的集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型[]  Array&lt;类型&gt; 都可以用于声明数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组要求的是存储的格式按照特定类型来存储，不关心位置  </span></span><br><span class="line"><span class="comment">// 元组  tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你赋予的值要求得符合这个结构和顺序, 元组在新增内容的时候 不能增加额外的类型的值，只能是已有的，而且增加后无法访问</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经约定好没有第四个，后续增加的不算，访问的时候不能访问后增加，安全问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">item</span>: <span class="built_in">string</span> = tuple[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举： 自带类型的对象（自己有类型，就是一个对象）</span></span><br><span class="line"><span class="comment">// 约定一组格式我们会用枚举  状态码 权限 数据格式 标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护一组常量的时候 可以采用枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">STATUS</span> &#123; <span class="comment">// 常量枚举 不会额外编译成对象， 所以更节约</span></span><br><span class="line">    <span class="string">&#x27;OK&#x27;</span> = <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;NO_OK&#x27;</span> = <span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;NOT_FOUND&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型可以进行反举 （值是数字的时候 可以反过来枚举）, 枚举没有值会根据上面的索引来自动累加</span></span><br><span class="line"><span class="comment">// 异构枚举 就是枚举中不光有数字 还有字符串. 异构枚举上一个是字符串下一个无法推导</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="variable constant_">STATUS</span>[<span class="string">&#x27;OK&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// null  undefined  基本类型 ，正常情况下只能赋予给null 和 undefined </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 如果禁用非严格null检测，null和undefiend 可以赋予给任何类型 （null,undefiend任何类型的子类型）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void 类型代表的是空类型    undefiend   void  这个void一般值表示函数的返回值</span></span><br><span class="line"><span class="comment">// unefiend 可以赋予给void， 都代表空 (undefiend 是 void的子类型)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// never 永远不，永远达到不了的地方就是never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数无法执行完毕</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">whileTrue</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;; <span class="comment">// 函数无法达到执行完毕的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(); <span class="comment">// 出错函数无法执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果if/else 条件都走完了， 没有遗漏的 后面的类型就是never (完整性保护)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 111  [1,1,1]</span></span><br><span class="line"><span class="comment">// &#x27;111&#x27; [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span></span><br><span class="line"><span class="comment">// true [&#x27;t&#x27;,&#x27;r&#x27;,&#x27;u&#x27;,&#x27;e&#x27;]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateCheck</span>(<span class="params">v:<span class="built_in">never</span></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">val:<span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> val.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>) <span class="comment">// [1,1,1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> val.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)<span class="comment">// [1,1,1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;boolean&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> val.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// [1,1,1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// never类型 只能被never类型来赋予值</span></span><br><span class="line">    <span class="title function_">validateCheck</span>(val); <span class="comment">// 代码的完整性保护</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">toArray</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// any 任何类型 能不写any 就不要用any ， any会导致类型丧失检测  anyScript(如果我们的项目是采用ts编写的，一般情况下any的出现场景不多) 放弃检测，出错就怨自己。 没有ts的加持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let a1:any = 1;</span></span><br><span class="line"><span class="comment">// a1 = &#x27;1&#x27;;</span></span><br><span class="line"><span class="comment">// a2 = function()&#123;&#125;</span></span><br><span class="line"><span class="comment">// object 引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">val:<span class="built_in">object</span></span>)&#123; <span class="comment">// &#123;&#125; object Object的区别</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">create</span>(&#123;&#125;)</span><br><span class="line"><span class="title function_">create</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="title function_">create</span>([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">symbol</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()..</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bigint</span>:<span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// symbol bigInt</span></span><br><span class="line"><span class="comment">// 非严格模式在关闭的时候 null可以赋予给undefiend</span></span><br><span class="line"><span class="comment">// string number boolean 数组  元组 枚举  null undefiend void never any objectr symbol bigInt </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; &#125; <span class="comment">// 这是一个独立的模块，不好影响其他人</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-类型推导-type-inference"><a href="#3-类型推导-type-inference" class="headerlink" title="3.类型推导(type inference)"></a>3.类型推导(type inference)</h1><h2 id="一-类型推导"><a href="#一-类型推导" class="headerlink" title="一. 类型推导"></a>一. 类型推导</h2><p>声明变量没有赋予值时默认变量是<code>any</code>类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name; <span class="comment">// 类型为any</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>声明变量赋值时则以赋值类型为准</strong></p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// name被推导为字符串类型 </span></span><br><span class="line">name = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;  <span class="comment">// 类型被推导为 number</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量<code>x</code>的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]; <span class="comment">// 类型被推导为 number | null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了推断<code>x</code>的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
</blockquote>
<p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo = [<span class="keyword">new</span> <span class="title class_">Rhino</span>(), <span class="keyword">new</span> <span class="title class_">Elephant</span>(), <span class="keyword">new</span> <span class="title class_">Snake</span>()];  <span class="comment">// (Rhino | Elephant | Snake)[]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，我们想让zoo被推断为<code>Animal[]</code>类型，但是这个数组里没有对象是<code>Animal</code>类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">zoo</span>: <span class="title class_">Animal</span>[] = [<span class="keyword">new</span> <span class="title class_">Rhino</span>(), <span class="keyword">new</span> <span class="title class_">Elephant</span>(), <span class="keyword">new</span> <span class="title class_">Snake</span>()];</span><br></pre></td></tr></table></figure>
<p> const 是常量意味着定义的值不会修改所以他的类型是一个字面量类型 . const声明变量必须复制 </p>
<p> let 声明变量 可以修改所以类型范围推到的结果会变大</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="number">1</span> <span class="comment">// const a1: 1</span></span><br><span class="line"><span class="keyword">let</span> a2  = <span class="number">1</span>  <span class="comment">// let a2: number</span></span><br></pre></td></tr></table></figure>
<h4 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h4><p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">mouseEvent</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mouseEvent.<span class="property">button</span>);  <span class="comment">//&lt;- Error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会得到一个类型错误，TypeScript类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 因此，就能推断出<code>mouseEvent</code>参数的类型了。 如果函数表达式不是在上下文类型的位置，<code>mouseEvent</code>参数的类型需要指定为<code>any</code>，这样也不会报错了。</p>
<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">mouseEvent: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mouseEvent.<span class="property">button</span>);  <span class="comment">//&lt;- Now, no error is given</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。</p>
<p>上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createZoo</span>(<span class="params"></span>): <span class="title class_">Animal</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">new</span> <span class="title class_">Rhino</span>(), <span class="keyword">new</span> <span class="title class_">Elephant</span>(), <span class="keyword">new</span> <span class="title class_">Snake</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhino</code>，<code>Elephant</code>和<code>Snake</code>。 当然，<code>Animal</code>会被做为最佳通用类型。</p>
<h3 id="二-包装对象"><a href="#二-包装对象" class="headerlink" title="二.包装对象"></a>二.包装对象</h3><p>我们在使用基本数据类型时，调用基本数据类型上的方法，默认会将原始数据类型包装成对象类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">bool1</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool2</span>:<span class="built_in">boolean</span> = <span class="title class_">Boolean</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool3</span>:<span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>boolean</em>是基本数据类型 , <em>Boolean</em>是他的封装类</p>
</blockquote>
<h3 id="三-联合类型（Union-Types）"><a href="#三-联合类型（Union-Types）" class="headerlink" title="三.联合类型（Union Types）"></a>三.联合类型（Union Types）</h3><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入<code>number</code>或<code>string</code>类型的参数。 例如下面的函数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个字符串，并在左侧添加“padding”.</span></span><br><span class="line"><span class="comment"> * 如果&#x27;padding&#x27;是一个字符串，那么&#x27;padding&#x27;会被添加到左侧.</span></span><br><span class="line"><span class="comment"> * 如果&#x27;padding&#x27;是一个数字，那么这个数量的空格将被添加到左侧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">padLeft</span>(<span class="string">&quot;Hello world&quot;</span>, <span class="number">4</span>); <span class="comment">// returns &quot;    Hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>padLeft</code>存在一个问题，<code>padding</code>参数的类型指定成了<code>any</code>。 这就是说我们可以传入一个既不是<code>number</code>也不是<code>string</code>类型的参数，但是TypeScript却不报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = <span class="title function_">padLeft</span>(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>
<p>在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 <code>padLeft</code>原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p>
<p>代替<code>any</code>， 我们可以使用<em>联合类型</em>做为<code>padding</code>的参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = <span class="title function_">padLeft</span>(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// errors during compilation</span></span><br></pre></td></tr></table></figure>
<p>联合类型表示一个值可以是几种类型之一。 我们用竖线（<code>|</code>）分隔每个类型，所以<code>number | string | boolean</code>表示一个值可以是<code>number</code>，<code>string</code>，或<code>boolean</code>。</p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="title function_">fly</span>();</span><br><span class="line">    <span class="title function_">layEggs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="title function_">swim</span>();</span><br><span class="line">    <span class="title function_">layEggs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line">pet.<span class="title function_">layEggs</span>(); <span class="comment">// okay</span></span><br><span class="line">pet.<span class="title function_">swim</span>();    <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>
<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是<code>A | B</code>，我们能够<em>确定</em>的是它包含了<code>A</code><em>和</em><code>B</code>中共有的成员。 这个例子里，<code>Bird</code>具有一个<code>fly</code>成员。 我们不能确定一个<code>Bird | Fish</code>类型的变量是否有<code>fly</code>方法。 如果变量在运行时是<code>Fish</code>类型，那么调用<code>pet.fly()</code>就出错了。</p>
<p>在使用联合类型时，没有赋值只能访问联合类型中共有的方法和属性</p>
<blockquote>
<p>如果是联合类型在使用方法的时候 只能采用公共的方法来使用</p>
<p> 还是从安全性考虑， 在使用联合类型的时候 我门通过会先定义值，在使用保证安全</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span> | <span class="built_in">number</span> <span class="comment">// 联合类型  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name!.<span class="title function_">toString</span>()); <span class="comment">// 公共方法</span></span><br><span class="line">name = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name!.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// number方法</span></span><br><span class="line">name = <span class="string">&#x27;zf&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name!.<span class="title function_">toLowerCase</span>()); <span class="comment">// 字符串方法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的!表示此值非空</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">ele</span>: <span class="title class_">HTMLElement</span> | <span class="literal">null</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line">ele!.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// 断定ele元素一定有值</span></span><br></pre></td></tr></table></figure>
<h4 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h4><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做<em>可辨识联合</em>的高级模式，它也称做<em>标签联合</em>或<em>代数数据类型</em>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>
<ol>
<li>具有普通的单例类型属性—<em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合—<em>联合</em>。</li>
<li>此属性上的类型保护。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们声明了将要联合的接口。 每个接口都有<code>kind</code>属性但有不同的字符串字面量类型。 <code>kind</code>属性称做<em>可辨识的特征</em>或<em>标签</em>。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Square</span> | <span class="title class_">Rectangle</span> | <span class="title class_">Circle</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们使用可辨识联合:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">s: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.<span class="property">kind</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>: <span class="keyword">return</span> s.<span class="property">size</span> * s.<span class="property">size</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;rectangle&quot;</span>: <span class="keyword">return</span> s.<span class="property">height</span> * s.<span class="property">width</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>: <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * s.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四-类型断言"><a href="#四-类型断言" class="headerlink" title="四.类型断言"></a>四.类型断言</h3><ul>
<li>类型断言</li>
</ul>
<p>​        类型断言有两种形式。 其一是“尖括号”语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>
<p>​    另一个为<code>as</code>语法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>
<p>我门断言类型后在使用 as断言成某种类型（一定是联合类型中的某一个） ! (非空断言， 表示这个值一定不是空的)不存在结果你自己承担， ts不管了，你认为的一定有值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">(name! <span class="keyword">as</span> <span class="built_in">number</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// 强制</span></span><br><span class="line">((&lt;<span class="built_in">number</span>&gt;name!).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>!TS语法  ?js语法 链判断运算符（如果值有再去取值</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="comment">// ele!.style.background = &#x27;red&#x27;;</span></span><br><span class="line">(ele <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>? 表示的是取值操作，不能赋值  ， ！表示某个变量一定存在</p>
<p> ele?.style.background</p>
<p> ?? js语法 合并空值运算符， 三元表达式 但是 false || 取的结果 </p>
<p> let val = 0 || 100 // 除了 null 和 undefiend 其他都是<strong>true</strong></p>
</blockquote>
<ul>
<li>双重断言</li>
</ul>
<blockquote>
<p>尽量不要使用双重断言，会破坏原有类型关系，断言为any是因为any类型可以被赋值给其他类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;Up&#x27;</span> | <span class="string">&#x27;Down&#x27;</span> | <span class="string">&#x27;Left&#x27;</span> | <span class="string">&#x27;Right&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">direction</span>:<span class="title class_">Direction</span> = <span class="string">&#x27;Down&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="五-字面量类型"><a href="#五-字面量类型" class="headerlink" title="五.字面量类型"></a>五.字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;Up&#x27;</span> | <span class="string">&#x27;Down&#x27;</span> | <span class="string">&#x27;Left&#x27;</span> | <span class="string">&#x27;Right&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">direction</span>:<span class="title class_">Direction</span> = <span class="string">&#x27;Down&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用字面量当做类型，同时也表明只能采用这几个值（限定值）。类似枚举。</p>
</blockquote>
<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Easing</span> = <span class="string">&quot;ease-in&quot;</span> | <span class="string">&quot;ease-out&quot;</span> | <span class="string">&quot;ease-in-out&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">    <span class="title function_">animate</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">&quot;ease-in&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&quot;ease-out&quot;</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&quot;ease-in-out&quot;</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// error! should not pass null or undefined.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> <span class="title class_">UIElement</span>();</span><br><span class="line">button.<span class="title function_">animate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;ease-in&quot;</span>);</span><br><span class="line">button.<span class="title function_">animate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;uneasy&quot;</span>); <span class="comment">// 错误:此处不允许使用“uneasy”</span></span><br></pre></td></tr></table></figure>
<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>
<blockquote>
<p>类型“uneasy”的参数不能赋值给类型“ease-in”|“ease-out”|“ease-in-out”的参数</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Argument</span> <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">&#x27;&quot;uneasy&quot;&#x27;</span> is not assignable to parameter <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">&#x27;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字符串字面量类型还可以用于区分函数重载：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tagName: <span class="string">&quot;img&quot;</span></span>): <span class="title class_">HTMLImageElement</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tagName: <span class="string">&quot;input&quot;</span></span>): <span class="title class_">HTMLInputElement</span>;</span><br><span class="line"><span class="comment">// ... more overloads ...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="comment">// ... code goes here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h4><p>TypeScript还具有数字字面量类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rollDie</span>(<span class="params"></span>): <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="number">1</span> || x !== <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//         ~~~~~~~</span></span><br><span class="line">        <span class="comment">// Operator &#x27;!==&#x27; cannot be applied to types &#x27;1&#x27; and &#x27;2&#x27;.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，当<code>x</code>与<code>2</code>进行比较的时候，它的值必须为<code>1</code>，这就意味着上面的比较检查是非法的。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameResolver</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrResolver</span> = <span class="title class_">Name</span> | <span class="title class_">NameResolver</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title class_">Name</span> &#123;   <span class="comment">// NameOrResolver 起别名 n’=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">n</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起别名不会新建一个类型 - 它创建了一个新<em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;; <span class="comment">// T 起别名 value</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用类型别名来在属性里引用自己：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LinkedList</span>&lt;T&gt; = T &amp; &#123; <span class="attr">next</span>: <span class="title class_">LinkedList</span>&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">people</span>: <span class="title class_">LinkedList</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="keyword">var</span> s = people.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">var</span> s = people.<span class="property">next</span>.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">var</span> s = people.<span class="property">next</span>.<span class="property">next</span>.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">var</span> s = people.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span>.<span class="property">name</span></span><br></pre></td></tr></table></figure>
<p>然而，类型别名不能出现在声明右侧的任何地方。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Yikes</span> = <span class="title class_">Array</span>&lt;<span class="title class_">Yikes</span>&gt;; <span class="comment">// error 报错</span></span><br></pre></td></tr></table></figure>
<h4 id="接口-vs-类型别名"><a href="#接口-vs-类型别名" class="headerlink" title="接口 vs 类型别名"></a>接口 vs 类型别名</h4><p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p>
<p>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在<code>interfaced</code>上，显示它返回的是<code>Interface</code>，但悬停在<code>aliased</code>上时，显示的却是对象字面量类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Alias</span> = &#123; <span class="attr">num</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">aliased</span>(<span class="params">arg: Alias</span>): <span class="title class_">Alias</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">interfaced</span>(<span class="params">arg: Interface</span>): <span class="title class_">Interface</span>;</span><br></pre></td></tr></table></figure>
<p>另一个重要区别是类型别名不能被<code>extends</code>和<code>implements</code>（自己也不能<code>extends</code>和<code>implements</code>其它类型）。 因为<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Open/closed_principle">软件中的对象应该对于扩展是开放的，但是对于修改是封闭的</a>，你应该尽量去使用接口代替类型别名。</p>
<p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p>
<h3 id="赋值推断"><a href="#赋值推断" class="headerlink" title="赋值推断"></a>赋值推断</h3><p>赋值时推断，类型从右像左流动,会根据赋值推断出变量类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;zhufeng&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回值推断"><a href="#返回值推断" class="headerlink" title="返回值推断"></a>返回值推断</h3><p>自动推断函数返回值类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="函数推断"><a href="#函数推断" class="headerlink" title="函数推断"></a>函数推断</h3><p>函数从左到右进行推断</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Sum</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sum</span>: <span class="title class_">Sum</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>
<h3 id="属性推断"><a href="#属性推断" class="headerlink" title="属性推断"></a>属性推断</h3><p>可以通过属性值,推断出属性的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zf&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = person;</span><br></pre></td></tr></table></figure>
<h3 id="类型反推"><a href="#类型反推" class="headerlink" title="类型反推"></a>类型反推</h3><p>可以使用<code>typeof</code>关键字反推变量类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zf&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> person</span><br></pre></td></tr></table></figure>
<h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">job</span>:&#123;</span><br><span class="line">        <span class="attr">address</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> job = <span class="title class_">IPerson</span>[<span class="string">&#x27;job&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapPerson</span> = &#123;[key <span class="keyword">in</span> keyof <span class="title class_">IPerson</span>]:<span class="title class_">IPerson</span>[key]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>练习代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明类型的时候 如果没有标识类型 他是什么类型？  </span></span><br><span class="line"><span class="comment">// 没有复制的变量默认值是undefined 但是类型是any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 是常量意味着定义的值不会修改所以他的类型是一个字面量类型 . const声明变量必须复制 </span></span><br><span class="line"><span class="comment">// let 声明变量 可以修改所以类型范围推到的结果会变大</span></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a2  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言的问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strOrNum :<span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 如果是联合类型在使用方法的时候 只能采用公共的方法来使用</span></span><br><span class="line"><span class="comment">// 还是从安全性考虑， 在使用联合类型的时候 我门通过会先定义值，在使用. 保证安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1） 指定类型在使用</span></span><br><span class="line"><span class="comment">// strOrNum = &#x27;1&#x27;</span></span><br><span class="line"><span class="comment">// strOrNum.endsWith();</span></span><br><span class="line"><span class="comment">// strOrNum = 1</span></span><br><span class="line"><span class="comment">// strOrNum.toFixed()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 我门断言类型后在使用 as断言成某种类型（一定是联合类型中的某一个） ! (非空断言， 表示这个值一定不是空的)</span></span><br><span class="line"><span class="comment">// 不存在结果你自己承担， ts不管了，你认为的一定有值</span></span><br><span class="line">(strOrNum! <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">charCodeAt</span>(<span class="number">0</span>);</span><br><span class="line">(&lt;<span class="built_in">number</span>&gt;strOrNum!).<span class="title function_">toFixed</span>(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// !TS语法  ?js语法 链判断运算符（如果值有再去取值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ele = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="comment">// ele!.style.background = &#x27;red&#x27;;</span></span><br><span class="line">(ele <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 表示的是取值操作，不能赋值  ， ！表示某个变量一定存在</span></span><br><span class="line"><span class="comment">// ele?.style.background</span></span><br><span class="line"><span class="comment">// ?? js语法 合并空值运算符， 三元表达式 但是 false || 取的结果 </span></span><br><span class="line"><span class="comment">// let val = 0 || 100 // 除了 null 和 undefiend 其他都是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值  as xxx 或者 &lt;xxx&gt;值  一般用于联合类型. 将大范围的类型 断言成子类型</span></span><br><span class="line"></span><br><span class="line">(strOrNum! <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">boolean</span>); <span class="comment">// 双重断言，一般不建议使用，但是还会用到，破坏原有的关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名将类型提取出来</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;up&#x27;</span>|<span class="string">&#x27;down&#x27;</span>|<span class="string">&#x27;left&#x27;</span>|<span class="string">&#x27;right&#x27;</span>; <span class="comment">// 快速构建一个可以复用的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">direction</span>:<span class="title class_">Direction</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">up</span>:<span class="string">&#x27;down&#x27;</span> = direction! <span class="keyword">as</span> <span class="string">&#x27;down&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="4-函数-function"><a href="#4-函数-function" class="headerlink" title="4.函数 (function)"></a>4.函数 (function)</h1><p>​    函数中的类型 1）函数的声明方式 2） 函数的参数  3） 函数的返回值</p>
<p>​    function关键字来声明的函数可以提升到当前作用域顶部</p>
<p>​    对于ts来说有区别： 函数关键字声明的函数 不能标注函数类型</p>
<p>​    通过表达式来声明的函数： 必须赋予的值要满足定义的类型 (要求有一个兼容性在里面)</p>
<h3 id="函数的两种声明方式"><a href="#函数的两种声明方式" class="headerlink" title="函数的两种声明方式"></a>函数的两种声明方式</h3><ul>
<li><p>通过function关键字来进行声明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>可以用来限制函数的参数和返回值类型</strong></p>
</blockquote>
</li>
<li><p>通过表达式方式声明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Sum</span> = <span class="function">(<span class="params">a1: <span class="built_in">string</span>, b1: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sum</span>: <span class="title class_">Sum</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p>书写完整函数类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1)函数类型的定义  (a: any, b: any) =&gt; any  ｜   (a: any, b: any) : any</span></span><br><span class="line"> <span class="keyword">type</span> <span class="title class_">ISum</span> = &#123;(<span class="attr">a</span>: <span class="built_in">any</span>, <span class="attr">b</span>: <span class="built_in">any</span>) : <span class="built_in">any</span>&#125;</span><br><span class="line"> <span class="keyword">type</span> <span class="title class_">ISum</span> =  <span class="function">(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"> <span class="keyword">const</span> <span class="attr">sum</span>:<span class="title class_">ISum</span>  = <span class="keyword">function</span>(<span class="params">a:<span class="built_in">string</span>,b:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 如果标明函数的类型，在使用函数的时候以标明的为准</p>
</blockquote>
<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>
<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为<code>void</code>而不能留空。</p>
<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p>
<h3 id="函数的推断类型"><a href="#函数的推断类型" class="headerlink" title="函数的推断类型"></a>函数的推断类型</h3><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type  myAdd具有完整的函数类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number 参数&#x27; x &#x27;和&#x27; y &#x27;的类型是number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p>这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>TypeScript里的每个函数参数都是必须的。 这不是指不能传递<code>null</code>或<code>undefined</code>作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// error, 缺少参数</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, 多余参数</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// ah, 刚刚好</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可选参数</p>
<p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用<code>?</code>实现可选参数的功能。 比如，我们想让last name是可选的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// 现在可以正常工作了</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, 参数太多</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  <span class="comment">// ah, 刚刚好</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。</p>
</blockquote>
<p>参数 可选参数<code>?</code>可选参数 意味着可以不传  和 string | undefiend 必须得传。 可选参数只能在参数列表中的后面</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ISum</span> =  <span class="function">(<span class="params">a: <span class="built_in">string</span>, b?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> <span class="comment">// 可选参数必须在其他参数的最后面</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="keyword">function</span>(<span class="params">a:<span class="built_in">string</span>,b:<span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果是兼容处理 采用的是自己标识的  不是你复制的类型</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 可选参数必须在其他参数的最后面</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认参数</p>
<p>在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是<code>undefined</code>时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为<code>&quot;Smith&quot;</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = <span class="string">&quot;Smith&quot;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// 现在工作正常，返回“Bob” Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="literal">undefined</span>);       <span class="comment">// 仍然有效，也返回“ &quot;Bob Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, 参数太多</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// ah, 刚刚好</span></span><br></pre></td></tr></table></figure>
<p>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = <span class="string">&quot;Smith&quot;</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享同样的类型<code>(firstName: string, lastName?: string) =&gt; string</code>。 默认参数的默认值消失了，只保留了它是一个可选参数的信息。</p>
<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入<code>undefined</code>值来获得默认值。 例如，我们重写最后一个例子，让<code>firstName</code>是带默认值的参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName = <span class="string">&quot;Will&quot;</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// error, 参数太少</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, 参数太多</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// okay 返回 &quot;Bob Adams&quot;</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&quot;Adams&quot;</span>);     <span class="comment">// okay 返回 &quot;Will Adams&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = (<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span> = <span class="string">&#x27;b&#x27;</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 默认参数必须在其他参数的最后面</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数中有arguments 但是我们不建议使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args:<span class="built_in">number</span>[]</span>):<span class="built_in">number</span>&#123; <span class="comment">// （函数式编程 入参和返回值 组合式api） 函数 （不考虑使用this 和 arguments）</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">memo,current</span>)=&gt;</span>(memo += current,memo),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数的类型直接参数后面:标识  函数的返回值在 &#123;&#125;前面来标识</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sum</span>: <span class="function">(<span class="params">...args:<span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> = (...<span class="attr">args</span>:<span class="built_in">any</span>[]) :<span class="function"><span class="params">any</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用<code>arguments</code>来访问所有传入的参数。</p>
<blockquote>
<p>函数中有arguments 但是我们不建议使用</p>
</blockquote>
<p>在TypeScript里，你可以把所有参数收集到一个变量里：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">buildName</span>(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（<code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>
<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">buildNameFun</span>: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = (...<span class="attr">args</span>: <span class="built_in">string</span>[]): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">memo, current</span>) =&gt;</span> memo += current, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args:<span class="built_in">number</span>[]</span>):<span class="built_in">number</span>&#123; <span class="comment">// （函数式编程 入参和返回值 组合式api） 函数 （不考虑使用this 和 arguments）</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">memo,current</span>)=&gt;</span>(memo += current,memo),<span class="number">0</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数的类型直接参数后面:标识  函数的返回值在 &#123;&#125;前面来标识</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sum</span>: <span class="function">(<span class="params">...args:<span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> = (...<span class="attr">args</span>:<span class="built_in">any</span>[]) :<span class="function"><span class="params">any</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h3><p>学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清<code>this</code>工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了<code>this</code>的地方。 如果你想了解JavaScript里的<code>this</code>是如何工作的，那么首先阅读Yehuda Katz写的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda的文章详细的阐述了<code>this</code>的内部工作原理，因此我们这里只做简单介绍。</p>
<ul>
<li><p><code>this</code>和箭头函数</p>
<p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>
<p>下面看一个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>();</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到<code>createCardPicker</code>是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为<code>createCardPicker</code>返回的函数里的<code>this</code>被设置成了<code>window</code>而不是<code>deck</code>对象。 因为我们只是独立的调用了<code>cardPicker()</code>。 顶级的非方法式调用会将<code>this</code>视为<code>window</code>。 （注意：在严格模式下，<code>this</code>为<code>undefined</code>而不是<code>window</code>）。</p>
<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的<code>this</code>值，而不是调用时的值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture &#x27;this&#x27; right here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>();</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>
<p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。 它会指出<code>this.suits[pickedSuit]</code>里的<code>this</code>的类型为<code>any</code>。</p>
</li>
</ul>
<h4 id="this参数"><a href="#this参数" class="headerlink" title="this参数"></a><code>this</code>参数</h4><blockquote>
<p>尽量不采用this 来作为函数的上下文， this的缺陷就是类型推导问题</p>
<p>如果想限制this类型 那么需要手动指定this类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params"><span class="variable language_">this</span>: IPerson, key: IKeys</span>) &#123; <span class="comment">// this不是行参 是标明this的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，<code>this.suits[pickedSuit]</code>的类型依旧为<code>any</code>。 这是因为<code>this</code>来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的<code>this</code>参数。 <code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">card</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">    <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>();</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>
<p>现在TypeScript知道<code>createCardPicker</code>期望在某个<code>Deck</code>对象上调用。 也就是说<code>this</code>是<code>Deck</code>类型的，而非<code>any</code>，因此<code>--noImplicitThis</code>不会报错了。</p>
<h4 id="回调函数里的this参数"><a href="#回调函数里的this参数" class="headerlink" title="回调函数里的this参数"></a>回调函数里的<code>this</code>参数</h4><p>当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的<code>this</code>会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，<code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过<code>this</code>参数来避免错误。 首先，库函数的作者要指定<code>this</code>的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">    <span class="title function_">addClickListener</span>(<span class="attr">onclick</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this: void</code>意味着<code>addClickListener</code>期望<code>onclick</code>是一个函数且它不需要一个<code>this</code>类型。 然后，为调用代码里的<code>this</code>添加类型注解：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">onClickBad</span>(<span class="params"><span class="variable language_">this</span>: Handler, e: Event</span>) &#123;</span><br><span class="line">        <span class="comment">// oops, used this here. using this callback would crash at runtime</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">info</span> = e.<span class="property">message</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickBad</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后TypeScript会检测到<code>addClickListener</code>要求函数带有<code>this: void</code>。 改变<code>this</code>类型来修复这个错误：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">onClickGood</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t use this here because it&#x27;s of type void!</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickGood</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用<code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">info</span> = e.<span class="property">message</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是可行的因为箭头函数不会捕获<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个<code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到<code>Handler</code>的原型链上。 它们在不同<code>Handler</code>对象间是共享的。</p>
<h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</p>
<p>ts 中函数有一个概念 叫重载(类型的重载)， 对于强类型语言可以一个函数写多遍（参数不同） js实现重载考的是arguments</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// Check to see if we&#x27;re working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we&#x27;ll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; <span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)];</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard1.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard1.<span class="property">suit</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard2.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard2.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>
<p><code>pickCard</code>方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>
<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载<code>pickCard</code>函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): &#123;<span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// Check to see if we&#x27;re working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we&#x27;ll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; <span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)];</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard1.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard1.<span class="property">suit</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard2.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard2.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>
<p>这样改变后，重载的<code>pickCard</code>函数在调用的时候会进行正确的类型检查。</p>
<p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<p>注意，<code>function pickCard(x): any</code>并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用<code>pickCard</code>会产生错误。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="built_in">string</span>[]<span class="comment">// 具体的某一种方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span>[];</span><br><span class="line"><span class="comment">// 上面的声明仅仅是类型上的重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span>[] | <span class="built_in">number</span>[] &#123; <span class="comment">// 所有的实现</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title function_">toArray</span>(<span class="string">&#x27;abc&#x27;</span>)<span class="comment">// 根据传入不同类型的数据 返回不同的结果</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title function_">toArray</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>练习代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数中的类型 1）函数的声明方式 2） 函数的参数  3） 函数的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function关键字来声明的函数可以提升到当前作用域顶部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于ts来说有区别： 函数关键字声明的函数 不能标注函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过表达式来声明的函数： 必须赋予的值要满足定义的类型 (要求有一个兼容性在里面)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function sum(a,b)&#123;</span></span><br><span class="line"><span class="comment">//     return a+b</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1)函数类型的定义  (a: any, b: any) =&gt; any  ｜   (a: any, b: any) : any</span></span><br><span class="line"><span class="comment">// type ISum = &#123;(a: any, b: any) : any&#125;</span></span><br><span class="line"><span class="comment">// type ISum =  (a: any, b: any) =&gt; any</span></span><br><span class="line"><span class="comment">// const sum:ISum  = function(a:string,b:string)&#123;</span></span><br><span class="line"><span class="comment">//     return a+b</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 如果标明函数的类型，在使用函数的时候以标明的为准</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)参数 可选参数 ? 可选参数 意味着可以不传 和 string | undefiend 必须得传。 可选参数只能在参数列表中的后面</span></span><br><span class="line"><span class="comment">// 默认值 = </span></span><br><span class="line"><span class="comment">// type ISum =  (a: string, b?: string) =&gt; string</span></span><br><span class="line"><span class="comment">// const sum = function(a:string,b:string = &#x27;abc&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//     return a+b</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 这里如果是兼容处理 采用的是自己标识的  不是你复制的类型</span></span><br><span class="line"><span class="comment">// sum(&#x27;1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 参数this问题</span></span><br><span class="line"><span class="comment">// 尽量不采用this 来作为函数的上下文， this的缺陷就是类型推导问题</span></span><br><span class="line"><span class="comment">// 如果想限制this类型 那么需要手动指定this类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params"><span class="variable language_">this</span>: IPerson, key: IKeys</span>) &#123; <span class="comment">// this不是行参 是标明this的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我想根据值来获得类型  typeof， 配合type来声明新的类型</span></span><br><span class="line"><span class="comment">// keyof 可以获取对象中的类型 作为联合类型</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;jw&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: <span class="string">&#x27;昌平霍营&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPerson</span> = <span class="keyword">typeof</span> person; <span class="comment">// 提取对象的类型为IPerson, type类型会提升到顶部</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IKeys</span> = keyof <span class="title class_">IPerson</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将子类型赋予给父类型 </span></span><br><span class="line">getValue.<span class="title function_">call</span>(person, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中有arguments 但是我们不建议使用</span></span><br><span class="line"><span class="comment">// function sum(...args:number[]):number&#123; // （函数式编程 入参和返回值 组合式api） 函数 （不考虑使用this 和 arguments）</span></span><br><span class="line"><span class="comment">//     return args.reduce((memo,current)=&gt;(memo += current,memo),0)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数的类型直接参数后面:标识  函数的返回值在 &#123;&#125;前面来标识</span></span><br><span class="line"><span class="comment">// const sum: (...args:any[])=&gt; any = (...args:any[]) :any=&gt; &#123;</span></span><br><span class="line"><span class="comment">//     return </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 中函数有一个概念 叫重载(类型的重载)， 对于强类型语言可以一个函数写多遍（参数不同） js实现重载考的是arguments</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参是一个字符串 或者是数字  -》 【‘字符串’】  【‘数字’】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// string[] | number[]    (number|string)[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="built_in">string</span>[]<span class="comment">// 具体的某一种方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span>[];</span><br><span class="line"><span class="comment">// 上面的声明仅仅是类型上的重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span>[] | <span class="built_in">number</span>[] &#123; <span class="comment">// 所有的实现</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title function_">toArray</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title function_">toArray</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="4-类-class"><a href="#4-类-class" class="headerlink" title="4.类(class)"></a>4.类(class)</h1><p>类： 类的组成： 构造函数、属性（实例属性，原型属性、静态属性）、方法 （实例的方法，原型方法，静态方法） 访问器， 静态相关的配置</p>
<h3 id="TS中定义类"><a href="#TS中定义类" class="headerlink" title="TS中定义类"></a>TS中定义类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span>&#123;</span><br><span class="line">    x!:<span class="built_in">number</span>; <span class="comment">// 实例上的属性必须先声明</span></span><br><span class="line">    y!:<span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>,y?:<span class="built_in">number</span>,...args:<span class="built_in">number</span>[]</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Pointer</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// 给这个类来声明属性 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">x</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">fn</span>: <span class="function">()=&gt;</span> <span class="built_in">void</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span> = <span class="number">200</span></span>)&#123; <span class="comment">// 函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span> = <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实例上的属性需要先声明在使用，构造函数中的参数可以使用可选参数和剩余参数</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个<code>Greeter</code>类。这个类有3个成员：一个叫做<code>greeting</code>的属性，一个构造函数和一个<code>greet</code>方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了<code>this</code>。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用<code>new</code>构造了<code>Greeter</code>类的一个实例。 它会调用之前定义的构造函数，创建一个<code>Greeter</code>类型的新对象，并执行构造函数初始化它。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code>是一个<em>派生类</em>，它派生自<code>Animal</code><em>基类</em>，通过<code>extends</code>关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>
<p>因为<code>Dog</code>继承了<code>Animal</code>的功能，因此我们可以创建一个<code>Dog</code>的实例，它能够<code>bark()</code>和<code>move()</code>。</p>
<p>下面我们来看个更加复杂的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="variable language_">super</span>(name); &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Slithering...&quot;</span>);</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="variable language_">super</span>(name); &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">45</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Galloping...&quot;</span>);</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&quot;Sammy the Python&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&quot;Tommy the Palomino&quot;</span>);</span><br><span class="line"></span><br><span class="line">sam.<span class="title function_">move</span>();</span><br><span class="line">tom.<span class="title function_">move</span>(<span class="number">34</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用<code>extends</code>关键字创建了<code>Animal</code>的两个子类：<code>Horse</code>和<code>Snake</code>。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它<em>必须</em>调用<code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问<code>this</code>的属性之前，我们<em>一定</em>要调用<code>super()</code>。 这个是TypeScript强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承来的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。 注意，即使<code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，调用<code>tom.move(34)</code>时，它会调用<code>Horse</code>里重写的方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Slithering</span>...</span><br><span class="line"><span class="title class_">Sammy</span> the <span class="title class_">Python</span> moved 5m.</span><br><span class="line"><span class="title class_">Galloping</span>...</span><br><span class="line"><span class="title class_">Tommy</span> the <span class="title class_">Palomino</span> moved 34m.</span><br></pre></td></tr></table></figure>
<h3 id="类中的修饰符"><a href="#类中的修饰符" class="headerlink" title="类中的修饰符"></a>类中的修饰符</h3><h4 id="public-修饰符（公开属性"><a href="#public-修饰符（公开属性" class="headerlink" title="public  修饰符（公开属性)"></a><code>public</code>  修饰符（公开属性)</h4><p>public 公开属性，类的实例在外部可以访问这个属性，类的内部也可以访问，继承的子类也可以访问</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> name!: <span class="built_in">string</span>; <span class="comment">// 不写public默认也是公开的</span></span><br><span class="line">    <span class="keyword">public</span> age!: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>); <span class="comment">// 子类访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>,p.<span class="property">age</span>); <span class="comment">// 外层访问</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过参数属性来简化父类中的代码</p>
</blockquote>
<h4 id="protected修饰符-自己和子类可以访问到"><a href="#protected修饰符-自己和子类可以访问到" class="headerlink" title="protected修饰符 (自己和子类可以访问到)"></a><code>protected</code>修饰符 (自己和子类可以访问到)</h4><p>我自己能访问，儿子能访问，外部无法访问</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> name: <span class="built_in">string</span>, <span class="keyword">protected</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>,p.<span class="property">age</span>);<span class="comment">// 无法访问</span></span><br></pre></td></tr></table></figure>
<h4 id="private修饰符-（私有的）"><a href="#private修饰符-（私有的）" class="headerlink" title="private修饰符 （私有的）"></a><code>private</code>修饰符 （私有的）</h4><p>除了自己都访问不到</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>); <span class="comment">// 无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>,p.<span class="property">age</span>);<span class="comment">// 无法访问</span></span><br></pre></td></tr></table></figure>
<h4 id="readonly修饰符-（仅读）"><a href="#readonly修饰符-（仅读）" class="headerlink" title="readonly修饰符 （仅读）"></a><code>readonly</code>修饰符 （仅读）</h4><p>readonly 标识仅读属性，意味着如果初始化后，不能被修改</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 仅读属性只能在constructor中被赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>); </span><br><span class="line">p.<span class="title function_">changeName</span>(<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>在上面的例子中，我们不得不定义一个受保护的成员<code>name</code>和一个构造函数参数<code>theName</code>在<code>Person</code>类里，并且立刻给<code>name</code>和<code>theName</code>赋值。 这种情况经常会遇到。<em>参数属性</em>可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前<code>Animal</code>类的修改版，使用了参数属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看我们是如何舍弃了<code>theName</code>，仅在构造函数里使用<code>private name: string</code>参数来创建和初始化<code>name</code>成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数添加一个访问限定符来声明。 使用<code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于<code>public</code>和<code>protected</code>来说也是一样。</p>
<h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用<code>get</code>和<code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="attr">fullName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以随意的设置<code>fullName</code>，这是非常方便的，但是这也可能会带来麻烦。</p>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对<code>fullName</code>的直接访问改成了可以检查密码的<code>set</code>方法。 我们也加了一个<code>get</code>方法，让上面的例子仍然可以工作。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;secret passcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;secret passcode&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>
<p>对于存取器有下面几点需要注意的：</p>
<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为<code>readonly</code>。 这在从代码生成<code>.d.ts</code>文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h4 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h4><p>创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用<code>static</code>定义<code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在<code>origin</code>前面加上类名。 如同在实例属性上使用<code>this.</code>前缀来访问属性一样，这里我们使用<code>Grid.</code>来访问静态属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="title function_">calculateDistanceFromOrigin</span>(<span class="params">point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.<span class="property">x</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.<span class="property">y</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(xDist * xDist + yDist * yDist) / <span class="variable language_">this</span>.<span class="property">scale</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (<span class="keyword">public</span> <span class="attr">scale</span>: <span class="built_in">number</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid1.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid2.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">type</span> = <span class="string">&#x27;哺乳动物&#x27;</span>; <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;动物类&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123; <span class="comment">// 属性访问器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animal.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态属性和静态方法是可以被子类所继承的</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span>  name:<span class="built_in">string</span></span>)&#123; <span class="comment">// 等价于 每个属性增添了public</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法 就是每一个实例共享的方法 , 父类提供的方法 子类是可以进行方法重写的</span></span><br><span class="line">    <span class="comment">// 原型的函数：void 意味着是不关心函数的返回值，并不是空的意思</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">changeName</span>(<span class="attr">value</span>:<span class="built_in">string</span>,<span class="attr">age</span>:<span class="built_in">number</span>):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型属性 需要通过访问器来实现</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">aliasName</span>()&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;$&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">alisName</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getA</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Super属性-继承-extends"><a href="#Super属性-继承-extends" class="headerlink" title="Super属性 (继承 extends)"></a>Super属性 (继承 extends)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params">message:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getType</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;动物&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params"></span>)&#123; <span class="comment">// 原型方法中的super指代的是父类的原型</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">say</span>(<span class="string">&#x27;猫猫叫&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getType</span>(<span class="params"></span>)&#123; <span class="comment">// 静态方法中的super指代的是父类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getType</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="title function_">getType</span>())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>super在构造函数 指向的是父类，在原型的方法中调用的时候指向的是父类的原型</p>
<p>super在 类中访问 constructor / static函数中执指向的都是父类  ,在原型方法中， 属性访问器都是 父类的原型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// super在构造函数 指向的是父类，在原型的方法中调用的时候指向的是父类的原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>,<span class="keyword">public</span> <span class="keyword">readonly</span> age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name); <span class="comment">// Animal.call(this)</span></span><br><span class="line">        <span class="comment">// this.age = age;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类在重写父类方法要兼容, 赋予的函数可以兼容父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">changeName</span>(<span class="params">value:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">changeName</span>(value,<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tom1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> tom2 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="title function_">getA</span>()); </span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 自己本身创造一个实例，后续一致用这一个，不产生多个</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">constructor</span>(<span class="params"></span>)&#123; &#125; <span class="comment">// 增加protected之后 构造函数不能被new了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类在什么时候 不用外面new</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>
<p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code>是一个<em>派生类</em>，它派生自<code>Animal</code><em>基类</em>，通过<code>extends</code>关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>
<p>因为<code>Dog</code>继承了<code>Animal</code>的功能，因此我们可以创建一个<code>Dog</code>的实例，它能够<code>bark()</code>和<code>move()</code>。</p>
<p>下面我们来看个更加复杂的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="variable language_">super</span>(name); &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Slithering...&quot;</span>);</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="variable language_">super</span>(name); &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">45</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Galloping...&quot;</span>);</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&quot;Sammy the Python&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&quot;Tommy the Palomino&quot;</span>);</span><br><span class="line"></span><br><span class="line">sam.<span class="title function_">move</span>();</span><br><span class="line">tom.<span class="title function_">move</span>(<span class="number">34</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用<code>extends</code>关键字创建了<code>Animal</code>的两个子类：<code>Horse</code>和<code>Snake</code>。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它<em>必须</em>调用<code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问<code>this</code>的属性之前，我们<em>一定</em>要调用<code>super()</code>。 这个是TypeScript强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承来的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。 注意，即使<code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，调用<code>tom.move(34)</code>时，它会调用<code>Horse</code>里重写的方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Slithering</span>...</span><br><span class="line"><span class="title class_">Sammy</span> the <span class="title class_">Python</span> moved 5m.</span><br><span class="line"><span class="title class_">Galloping</span>...</span><br><span class="line"><span class="title class_">Tommy</span> the <span class="title class_">Palomino</span> moved 34m.</span><br></pre></td></tr></table></figure>
<h3 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h3><h4 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a><strong>装饰类</strong></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addSay</span>(<span class="params">target:<span class="built_in">any</span></span>)&#123;</span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;say&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@addSay</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    say!:<span class="title class_">Function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span></span><br><span class="line">person.<span class="title function_">say</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>装饰类可以给类扩展功能,需要开启<code>experimentalDecorators:true</code></p>
</blockquote>
<h4 id="装饰类中属性"><a href="#装饰类中属性" class="headerlink" title="装饰类中属性"></a>装饰类中属性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toUpperCase</span>(<span class="params">target:<span class="built_in">any</span>,key:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> value = target[key]; </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target,key,&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> value.<span class="title function_">toUpperCase</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">            value = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = target[key];</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;value = newValue&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@toUpperCase</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;JiangWen&#x27;</span></span><br><span class="line">	<span class="meta">@double</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>(),<span class="title class_">Person</span>.<span class="property">age</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>装饰属性可以对属性的内容进行改写，装饰的是实例属性则target指向类的原型、装饰的是静态属性则target执行类本身~</p>
</blockquote>
<h4 id="装饰类中方法"><a href="#装饰类中方法" class="headerlink" title="装饰类中方法"></a>装饰类中方法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">noEnum</span>(<span class="params">target:<span class="built_in">any</span>,key:<span class="built_in">string</span>,descriptor:PropertyDescriptor</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor)</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@toUpperCase</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;JiangWen&#x27;</span></span><br><span class="line">    <span class="meta">@double</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@noEnum</span></span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// getName 不可枚举</span></span><br></pre></td></tr></table></figure>
<h4 id="装饰参数"><a href="#装饰参数" class="headerlink" title="装饰参数"></a>装饰参数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addPrefix</span>(<span class="params">target:<span class="built_in">any</span>,key:<span class="built_in">string</span>,paramIndex:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target,key,paramIndex); <span class="comment">// Person.prototype getName  0 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@toUpperCase</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;JiangWen&#x27;</span></span><br><span class="line">    <span class="meta">@double</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">    prefix!:<span class="built_in">string</span></span><br><span class="line">    <span class="meta">@noEnum</span></span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"><span class="meta">@addPrefix</span> prefix:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&#x27;roaming the earch...&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&#x27;Accounting and Auditing&#x27;</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generating accounting reports...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span>; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>();</span><br><span class="line">department.<span class="title function_">printMeeting</span>();</span><br><span class="line">department.<span class="title function_">generateReports</span>(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>
<p>抽象类无法被实例化，只能被继承，抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现,而且必须实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    name!:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">speak</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;猫猫叫&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">    <span class="title function_">speak</span>():<span class="built_in">string</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;汪汪叫&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;wangwang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义类型时<code>void</code>表示函数的返回值为空（不关心返回值类型，所有在定义函数时也不关心函数返回值类型）</p>
</blockquote>
<p>ts 中有抽象类概念， abstract 不存在的</p>
<p>抽象类 可以含义非抽象的方法和属性 ， 不会new它 , 抽象类可以被继承，抽象类中抽象方法子类必须要实现</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="attr">a</span>:<span class="built_in">string</span></span><br><span class="line">        <span class="title function_">drink</span>(<span class="params"></span>)&#123; <span class="comment">// 非抽象，已经有实现了</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喝水&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="title function_">eat</span>():<span class="built_in">void</span> <span class="comment">// 抽象的方法，父类没有实现，那么子类必须实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">        <span class="title function_">eat</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为我们编写的代码的时候 ， 慢慢的脱离继承了。 组合优于继承。   类的装饰器（redux，nest， mobx）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的<em>实例</em>的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter</span>: <span class="title class_">Greeter</span>;</span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>());</span><br></pre></td></tr></table></figure>
<p>这里，我们写了<code>let greeter: Greeter</code>，意思是<code>Greeter</code>类的实例的类型是<code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做<em>构造函数</em>的值。 这个函数会在我们使用<code>new</code>创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Greeter</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Greeter</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter;</span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>());</span><br></pre></td></tr></table></figure>
<p>上面的代码里，<code>let Greeter</code>将被赋值为构造函数。 当我们调用<code>new</code>并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>
<p>让我们稍微改写一下这个例子，看看它们之前的区别：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> standardGreeting = <span class="string">&quot;Hello, there&quot;</span>;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">greeting</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Greeter</span>.<span class="property">standardGreeting</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter1</span>: <span class="title class_">Greeter</span>;</span><br><span class="line">greeter1 = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter1.<span class="title function_">greet</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeterMaker</span>: <span class="keyword">typeof</span> <span class="title class_">Greeter</span> = <span class="title class_">Greeter</span>;</span><br><span class="line">greeterMaker.<span class="property">standardGreeting</span> = <span class="string">&quot;Hey there!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter2</span>: <span class="title class_">Greeter</span> = <span class="keyword">new</span> <span class="title function_">greeterMaker</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter2.<span class="title function_">greet</span>());</span><br></pre></td></tr></table></figure>
<p>这个例子里，<code>greeter1</code>与之前看到的一样。 我们实例化<code>Greeter</code>类，并使用这个对象。 与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。 我们创建了一个叫做<code>greeterMaker</code>的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用<code>typeof Greeter</code>，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我<code>Greeter</code>标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在<code>greeterMaker</code>上使用<code>new</code>，创建<code>Greeter</code>的实例。</p>
<h4 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h4><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point3d</span>: <span class="title class_">Point3</span>d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>练习代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类： 类的组成： 构造函数、属性（实例属性，原型属性、静态属性）、方法 （实例的方法，原型方法，静态方法） 访问器， 静态相关的配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// 给这个类来声明属性 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">x</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">fn</span>: <span class="function">()=&gt;</span> <span class="built_in">void</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span> = <span class="number">200</span></span>)&#123; <span class="comment">// 函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span> = <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类的修饰符</span></span><br><span class="line"><span class="comment">// public 公开属性，类的实例在外部可以访问这个属性，类的内部也可以访问，继承的子类也可以访问</span></span><br><span class="line"><span class="comment">// protected (我自己能访问，儿子能访问，外部无法访问)</span></span><br><span class="line"><span class="comment">// private (私有的 自己能访问)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平时我们一般采用public 或者private的场景比较多.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// readonly 标识仅读属性，意味着如果初始化后，不能被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let circle = new Circle(100,100)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span>  name:<span class="built_in">string</span></span>)&#123; <span class="comment">// 等价于 每个属性增添了public</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法 就是每一个实例共享的方法 , 父类提供的方法 子类是可以进行方法重写的</span></span><br><span class="line">    <span class="comment">// 原型的函数：void 意味着是不关心函数的返回值，并不是空的意思</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">changeName</span>(<span class="attr">value</span>:<span class="built_in">string</span>,<span class="attr">age</span>:<span class="built_in">number</span>):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型属性 需要通过访问器来实现</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">aliasName</span>()&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;$&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">alisName</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getA</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// super在构造函数 指向的是父类，在原型的方法中调用的时候指向的是父类的原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>,<span class="keyword">public</span> <span class="keyword">readonly</span> age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name); <span class="comment">// Animal.call(this)</span></span><br><span class="line">        <span class="comment">// this.age = age;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类在重写父类方法要兼容, 赋予的函数可以兼容父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">changeName</span>(<span class="params">value:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">changeName</span>(value,<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tom1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> tom2 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="title function_">getA</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(tom1.aliasName === tom2.aliasName)</span></span><br><span class="line"><span class="comment">// tom.changeName(&#x27;jerry&#x27;)</span></span><br><span class="line"><span class="comment">// 以上用法同es6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// super在 类中访问 constructor / static函数中执指向的都是父类  ,在原型方法中， 属性访问器都是 父类的原型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 自己本身创造一个实例，后续一致用这一个，不产生多个</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">constructor</span>(<span class="params"></span>)&#123; &#125; <span class="comment">// 增加protected之后 构造函数不能被new了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类在什么时候 不用外面new</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 中有抽象类概念， abstract 不存在的</span></span><br><span class="line"><span class="comment">// 抽象类 可以含义非抽象的方法和属性 ， 不会new它 , 抽象类可以被继承，抽象类中抽象方法子类必须要实现</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="attr">a</span>:<span class="built_in">string</span></span><br><span class="line">        <span class="title function_">drink</span>(<span class="params"></span>)&#123; <span class="comment">// 非抽象，已经有实现了</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喝水&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="title function_">eat</span>():<span class="built_in">void</span> <span class="comment">// 抽象的方法，父类没有实现，那么子类必须实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">        <span class="title function_">eat</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为我们编写的代码的时候 ， 慢慢的脱离继承了。 组合优于继承。   类的装饰器（redux，nest， mobx）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="5-接口-interface"><a href="#5-接口-interface" class="headerlink" title="5.接口(interface)"></a>5.接口(interface)</h1><h3 id="文档的解释"><a href="#文档的解释" class="headerlink" title="文档的解释"></a>文档的解释</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labelledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj);</span><br></pre></td></tr></table></figure>
<p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123;<span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;<span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">color</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">area</span> = config.<span class="property">width</span> * config.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123;<span class="attr">color</span>: <span class="string">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将<code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">  let newSquare = &#123;color: &quot;white&quot;, area: 100&#125;;</span><br><span class="line">  if (config.color) &#123;</span><br><span class="line">    // Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span><br><span class="line">    newSquare.color = config.clor;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  return newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用<code>readonly</code>来指定只读属性:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后，<code>x</code>和<code>y</code>再也不能被改变了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.<span class="property">x</span> = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro as number[];</span><br></pre></td></tr></table></figure>
<h4 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h4><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>&#123; size: number; label: string; &#125;</code>到仅期望得到<code>&#123; label: string; &#125;</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿<code>createSquare</code>例子来说：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123; <span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在JavaScript里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过<em>额外属性检查</em>，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> <span class="title class_">SquareConfig</span>);</span><br></pre></td></tr></table></figure>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果<code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且<em>还会</em>带有任意数量的其它属性，那么我们可以这样定义它：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为<code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(squareOptions);</span><br></pre></td></tr></table></figure>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入<code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.<span class="title function_">search</span>(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是<code>false</code>和<code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">src, sub</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个<em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span>;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用&#x27;string&#x27;索引，有时会得到Animal!</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Animal</span>;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Dog</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了<code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberDictionary</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ReadonlyStringArray &#123;</span><br><span class="line">    readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];</span><br><span class="line">myArray[2] = &quot;Mallory&quot;; // error!</span><br></pre></td></tr></table></figure>
<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h4 id="类-类型"><a href="#类-类型" class="headerlink" title="类 类型"></a>类 类型</h4><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentTime</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h5 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h5><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，<code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数<code>createClock</code>，它用传入的类型创建实例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): <span class="title class_">ClockInterface</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">tick</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalogClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = <span class="title function_">createClock</span>(<span class="title class_">DigitalClock</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = <span class="title function_">createClock</span>(<span class="title class_">AnalogClock</span>, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125;;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">    <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>, <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125;;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span>;</span><br><span class="line">square.<span class="property">penWidth</span> = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    (<span class="attr">start</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">interval</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">reset</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>): <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;<span class="title class_">Counter</span>&gt;<span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) &#123; &#125;;</span><br><span class="line">    counter.<span class="property">interval</span> = <span class="number">123</span>;</span><br><span class="line">    counter.<span class="property">reset</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">getCounter</span>();</span><br><span class="line"><span class="title function_">c</span>(<span class="number">10</span>);</span><br><span class="line">c.<span class="title function_">reset</span>();</span><br><span class="line">c.<span class="property">interval</span> = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelectableControl</span> <span class="keyword">extends</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Property &#x27;state&#x27; is missing in type &#x27;Image&#x27;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为<code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有<code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法），但<code>Image</code>和<code>Location</code>类并不是这样的。</p>
<h3 id="学习的解释"><a href="#学习的解释" class="headerlink" title="学习的解释"></a>学习的解释</h3><p>接口可以在面向对象编程中表示行为的抽象，也可以描述对象的形状。 <em>接口</em>的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 (接口中不能含有具体的实现逻辑)</p>
<blockquote>
<p>接口： 抽象类（有抽象的也有非抽象）  接口必须都是抽象的（没有具体的实现）</p>
<p>接口的概念 就是描述数据的结构、或者形状的， 定义好结构，在去针对结构来进行实现</p>
<p>type 和 interface 区别</p>
<p>一般情况下 描述对象,类 我门采用interface更多一些 ，interface无法声明联合类型</p>
<p> type 可以快速声明类型 联合类型，工具类型只能采用type  , type不能重名</p>
<p>type用的更多，能用type 就type 不能用interface. 复杂类型采用type</p>
</blockquote>
<h4 id="函数接口参数"><a href="#函数接口参数" class="headerlink" title="函数接口参数"></a>函数接口参数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = (&#123;firstName,lastName&#125;:&#123;<span class="attr">firstName</span>:<span class="built_in">string</span>,<span class="attr">lastName</span>:<span class="built_in">string</span>&#125;):<span class="function"><span class="params">string</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以约束函数中的参数，但是类型无法复用</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFullName</span> &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fullName = (&#123;firstName,lastName&#125;:<span class="title class_">IFullName</span>):<span class="function"><span class="params">string</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以描述对象结构 （子可以赋予给父）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">     <span class="attr">username</span>: <span class="built_in">string</span> <span class="comment">// 类型，不是具体实现</span></span><br><span class="line">     <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子可以赋予给父亲。 我们需要把一个值赋予给另一个值。 如果是声明的必须必须一致</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">     <span class="attr">username</span>:<span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">     <span class="attr">age</span>:<span class="number">30</span>,</span><br><span class="line">     <span class="attr">address</span>:<span class="string">&#x27;地址&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:<span class="title class_">IPerson</span> = obj; <span class="comment">// 赋值的时候 会产生兼容性  （儿子可以赋予给父亲）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过接口进行描述</p>
</blockquote>
<h4 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IFullName</span> &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFn</span> &#123;</span><br><span class="line">    (<span class="attr">obj</span>:<span class="title class_">IFullName</span>):<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fullName</span>:<span class="title class_">IFn</span> = <span class="function">(<span class="params">&#123;firstName,lastName&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICounter</span> &#123;</span><br><span class="line">     ():<span class="built_in">number</span></span><br><span class="line">     <span class="attr">count</span>:<span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// const 标识此值不能修改  let 可以修改的 (如果给函数增加类型定义 函数不能被修改时只能用const)</span></span><br><span class="line"> <span class="keyword">const</span> <span class="attr">counter</span>:<span class="title class_">ICounter</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> counter.<span class="property">count</span>++</span><br><span class="line">&#125;</span><br><span class="line">counter.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过接口限制函数的参数类型和返回值类型</p>
</blockquote>
<h4 id="函数混合类型"><a href="#函数混合类型" class="headerlink" title="函数混合类型"></a>函数混合类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICounter</span> &#123;</span><br><span class="line">    (): <span class="built_in">number</span>; <span class="comment">// 限制函数类型</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span> <span class="comment">// 限制函数上的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn</span>: <span class="built_in">any</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fn.<span class="property">count</span>++;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">counter</span>:<span class="title class_">ICounter</span> = fn;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>());</span><br></pre></td></tr></table></figure>
<h4 id="对象接口"><a href="#对象接口" class="headerlink" title="对象接口"></a>对象接口</h4><p>对象接口可以用来描述对象的形状结构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IVegetables</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">color</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">size</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以通过?表示接口的属性 可有可无</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IVegetables</span>&#123;</span><br><span class="line">    age?:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">taste</span>:<span class="string">&#x27;sour&#x27;</span>|<span class="string">&#x27;sweet&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tomato</span>:<span class="title class_">IVegetables</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">size</span>:<span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">    <span class="attr">taste</span>:<span class="string">&#x27;sour&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">tomato.<span class="property">color</span> = <span class="string">&#x27;green&#x27;</span>; <span class="comment">// 仅读属性不能进行修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>？标识的属性为可选属性, <code>readOnly</code>标识的属性则不能修改。多个同名的接口会自动合并</p>
<p>断言的方式来进行赋值, 用的最多 as IVeg</p>
<p>接口的合并 同名的会进行合并,自定义类型的时候 会使用。 自己的业务逻辑用的比较少</p>
<p>可以扩展一个新类型 在来使用。 可以扩展属性</p>
<p>任意类型  随机的属性  描述数字索引的  (除了必有的属性之外 ，其他任意)</p>
<p>兼容性</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tomato</span>:<span class="title class_">IVegetables</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">size</span>:<span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">    <span class="attr">taste</span>:<span class="string">&#x27;sour&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;蔬菜&#x27;</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">IVegetables</span>; <span class="comment">// 多余的属性可以使用类型断言</span></span><br><span class="line"></span><br><span class="line">nterface <span class="title class_">IVeg</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="attr">taste</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IVegetable</span> <span class="keyword">extends</span> <span class="title class_">IVeg</span> &#123;</span><br><span class="line">    color?: <span class="string">&#x27;红色&#x27;</span>,</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> <span class="comment">// 任意接口 key 随意，值随意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">veg</span>: <span class="title class_">IVegetable</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;西红柿&#x27;</span>,</span><br><span class="line">    <span class="attr">taste</span>: <span class="string">&#x27;甜&#x27;</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;红色&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="string">&#x27;ABC&#x27;</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="任意属性、可索引接口"><a href="#任意属性、可索引接口" class="headerlink" title="任意属性、可索引接口"></a>任意属性、可索引接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhufeng&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]:<span class="string">&#x27;回龙观&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IArray</span> &#123; <span class="comment">// 索引接口</span></span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let arr:IArray = [1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">IArray</span> = &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="number">3</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ResponseData</span> &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">token</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnVal</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">ResponseData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引访问符 来获取内部类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ICode</span> = <span class="title class_">ReturnVal</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IUsername</span> = <span class="title class_">ReturnVal</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;username&#x27;</span>]; <span class="comment">// 可以用于取值的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IKeys</span> = <span class="title class_">ReturnVal</span>[keyof <span class="title class_">ReturnVal</span>]; <span class="comment">// 取值的类型, 可以采用这种方式</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>任意属性可以对某一部分必填属性做限制，其余的可以随意增减</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IArr</span> &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">IArr</span> = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;1&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">IArr</span> = [<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可索引接口可以用于标识数组</p>
</blockquote>
<h4 id="类接口"><a href="#类接口" class="headerlink" title="类接口"></a>类接口</h4><p>这里先来强调一下抽象类和接口的区别,抽象类中可以包含具体方法实现。接口中不能包含实现</p>
<blockquote>
<p>接口可以实现， 接口的实现都是通过类来实现 , 接口中一个类 可以实现多个接口</p>
<p>一个接口可以继承多个接口， 接口可以用于继承类</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Speakable</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">speak</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChineseSpeakable</span>&#123;</span><br><span class="line">    <span class="title function_">speakChinese</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speak</span> <span class="keyword">implements</span> <span class="title class_">Speakable</span>,<span class="title class_">ChineseSpeakable</span>&#123;</span><br><span class="line">    name!:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title function_">speakChinese</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个类可以实现多个接口，在类中必须实现接口中的方法和属性</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakChinese</span> &#123;</span><br><span class="line">    <span class="title function_">speakChinese</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakEnglish</span> &#123;</span><br><span class="line">    <span class="title function_">speakEnglish</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Speakable</span> <span class="keyword">extends</span> <span class="title class_">SpeakEnglish</span>, <span class="title class_">SpeakChinese</span>, <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="title function_">speak</span>(): <span class="built_in">void</span> <span class="comment">// 实现的是原型方法</span></span><br><span class="line">    <span class="comment">//  speak:()=&gt;void // 实现的是实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> <span class="keyword">implements</span> <span class="title class_">Speakable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">speakEnglish</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speakChinese</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我门如何表示我要传入的是一个类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125; <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类类型， 不能藐视类本身，描述的是实例</p>
<p> 类的类型 需要通过typeof 来取类型</p>
<p> ts的校验规则  鸭子类型检测</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述构造函数 </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IClazz</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">name</span>:<span class="built_in">string</span>): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IClazz</span>&lt;T&gt; = <span class="keyword">new</span> (<span class="attr">name</span>: <span class="built_in">string</span>) =&gt; T</span><br><span class="line"><span class="keyword">function</span> createInstance&lt;T&gt;(<span class="attr">clazz</span>: <span class="title class_">IClazz</span>&lt;T&gt;, <span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">clazz</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">createInstance</span>(<span class="title class_">Cat</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="comment">// 泛型： 泛型坑位 （函数的形式参数） 刚开始类型不确定，通过使用的时候 来确定类型</span></span><br></pre></td></tr></table></figure>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Speakable</span> &#123;</span><br><span class="line">    <span class="title function_">speak</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakChinese</span> <span class="keyword">extends</span> <span class="title class_">Speakable</span>&#123;</span><br><span class="line">    <span class="title function_">speakChinese</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speak</span> <span class="keyword">implements</span> <span class="title class_">SpeakChinese</span>&#123;</span><br><span class="line">    <span class="title function_">speakChinese</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speak</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数类型"><a href="#构造函数类型" class="headerlink" title="构造函数类型"></a>构造函数类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clazz</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">name</span>:<span class="built_in">string</span>):<span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClass</span>(<span class="params">target:Clazz,name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(name); <span class="comment">// 传入的是一个构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">createClass</span>(<span class="title class_">Animal</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里无法标识返回值类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clazz</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">new</span>(<span class="attr">name</span>: <span class="built_in">string</span>): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> createClass&lt;T&gt;(<span class="attr">target</span>: <span class="title class_">Clazz</span>&lt;T&gt;, <span class="attr">name</span>: <span class="built_in">string</span>):T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">createClass</span>(<span class="title class_">Animal</span>, <span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>new() 表示当前是一个构造函数类型,这里捎带使用了下泛型。 在使用<code>createClass</code>时动态传入类型</p>
</blockquote>
<ul>
<li><p>练习代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口： 抽象类（有抽象的也有非抽象）  接口必须都是抽象的（没有具体的实现）</span></span><br><span class="line"><span class="comment">// 接口的概念 就是描述数据的结构、或者形状的， 定义好结构，在去针对结构来进行实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type 和 interface 区别</span></span><br><span class="line"><span class="comment">// 一般情况下 描述对象,类 我门采用interface更多一些 ，interface无法声明联合类型</span></span><br><span class="line"><span class="comment">// type 可以快速声明类型 联合类型，工具类型只能采用type  , type不能重名</span></span><br><span class="line"><span class="comment">// type用的更多，能用type 就type 不能用interface. 复杂类型采用type</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 接口可以描述对象结构 （子可以赋予给父）</span></span><br><span class="line"><span class="comment">// interface IPerson &#123;</span></span><br><span class="line"><span class="comment">//     username: string // 类型，不是具体实现</span></span><br><span class="line"><span class="comment">//     age:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 子可以赋予给父亲。 我们需要把一个值赋予给另一个值。 如果是声明的必须必须一致</span></span><br><span class="line"><span class="comment">// let obj = &#123;</span></span><br><span class="line"><span class="comment">//     username:&#x27;abc&#x27;,</span></span><br><span class="line"><span class="comment">//     age:30,</span></span><br><span class="line"><span class="comment">//     address:&#x27;地址&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let person:IPerson = obj; // 赋值的时候 会产生兼容性  （儿子可以赋予给父亲）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2） 接口可以描述函数</span></span><br><span class="line"><span class="comment">// interface ICounter &#123;</span></span><br><span class="line"><span class="comment">//     ():number</span></span><br><span class="line"><span class="comment">//     count:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // const 标识此值不能修改  let 可以修改的 (如果给函数增加类型定义 函数不能被修改时只能用const)</span></span><br><span class="line"><span class="comment">// const counter:ICounter = () =&gt;&#123;</span></span><br><span class="line"><span class="comment">//     return counter.count++</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// counter.count = 0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）可以通过?表示接口的属性 可有可无</span></span><br><span class="line"><span class="comment">// interface IVeg &#123;</span></span><br><span class="line"><span class="comment">//     name: string</span></span><br><span class="line"><span class="comment">//     taste: string;</span></span><br><span class="line"><span class="comment">//     size: number,</span></span><br><span class="line"><span class="comment">//     color?: string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 2）断言的方式来进行赋值, 用的最多 as IVeg</span></span><br><span class="line"><span class="comment">// 3）接口的合并 同名的会进行合并,自定义类型的时候 会使用。 自己的业务逻辑用的比较少</span></span><br><span class="line"><span class="comment">// 4) 可以扩展一个新类型 在来使用。 可以扩展属性</span></span><br><span class="line"><span class="comment">// 5）任意类型  随机的属性  描述数字索引的  (除了必有的属性之外 ，其他任意)</span></span><br><span class="line"><span class="comment">// 6）兼容性 </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IVeg</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="attr">taste</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IVegetable</span> <span class="keyword">extends</span> <span class="title class_">IVeg</span> &#123;</span><br><span class="line">    color?: <span class="string">&#x27;红色&#x27;</span>,</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> <span class="comment">// 任意接口 key 随意，值随意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">veg</span>: <span class="title class_">IVegetable</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;西红柿&#x27;</span>,</span><br><span class="line">    <span class="attr">taste</span>: <span class="string">&#x27;甜&#x27;</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;红色&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="string">&#x27;ABC&#x27;</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IArray</span> &#123; <span class="comment">// 索引接口</span></span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let arr:IArray = [1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">IArray</span> = &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="number">3</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ResponseData</span> &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">token</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnVal</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">ResponseData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引访问符 来获取内部类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ICode</span> = <span class="title class_">ReturnVal</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IUsername</span> = <span class="title class_">ReturnVal</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;username&#x27;</span>]; <span class="comment">// 可以用于取值的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IKeys</span> = <span class="title class_">ReturnVal</span>[keyof <span class="title class_">ReturnVal</span>]; <span class="comment">// 取值的类型, 可以采用这种方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口可以实现， 接口的实现都是通过类来实现 , 接口中一个类 可以实现多个接口</span></span><br><span class="line"><span class="comment">// 一个接口可以继承多个接口， 接口可以用于继承类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakChinese</span> &#123;</span><br><span class="line">    <span class="title function_">speakChinese</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakEnglish</span> &#123;</span><br><span class="line">    <span class="title function_">speakEnglish</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Speakable</span> <span class="keyword">extends</span> <span class="title class_">SpeakEnglish</span>, <span class="title class_">SpeakChinese</span>, <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="title function_">speak</span>(): <span class="built_in">void</span> <span class="comment">// 实现的是原型方法</span></span><br><span class="line">    <span class="comment">//  speak:()=&gt;void // 实现的是实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> <span class="keyword">implements</span> <span class="title class_">Speakable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> a!: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">speakEnglish</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speakChinese</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我门如何表示我要传入的是一个类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125; <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类类型， 不能藐视类本身，描述的是实例</span></span><br><span class="line"><span class="comment">// 类的类型 需要通过typeof 来取类型</span></span><br><span class="line"><span class="comment">// ts的校验规则  鸭子类型检测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述构造函数 </span></span><br><span class="line"><span class="comment">// interface IClazz&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment">//     new (name:string): T</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IClazz</span>&lt;T&gt; = <span class="keyword">new</span> (<span class="attr">name</span>: <span class="built_in">string</span>) =&gt; T</span><br><span class="line"><span class="keyword">function</span> createInstance&lt;T&gt;(<span class="attr">clazz</span>: <span class="title class_">IClazz</span>&lt;T&gt;, <span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">clazz</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">createInstance</span>(<span class="title class_">Cat</span>, <span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="comment">// 泛型： 泛型坑位 （函数的形式参数） 刚开始类型不确定，通过使用的时候 来确定类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Tom</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://tom9527c.github.io/posts/9d362be7.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://tom9527c.github.io/posts/9d362be7.html')">TypeScript笔记（一）</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://tom9527c.github.io/posts/9d362be7.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=TypeScript笔记（一）&amp;url=https://tom9527c.github.io/posts/9d362be7.html&amp;pic=https://mypic-ezp.pages.dev/img/img33.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tom9527c.github.io" target="_blank">Tom</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>前端<span class="tagsPageCount">25</span></a><a class="post-meta__box__tags" href="/tags/TypeScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>TypeScript<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>笔记<span class="tagsPageCount">3</span></a><a class="post-meta__box__tags" href="/tags/%E7%BB%83%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>练习<span class="tagsPageCount">6</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/5459.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.guozy.online/img/2023/10/fa147b23bf1fbe949cf4915460950c39.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue3IX-组件渲染</div></div></a></div><div class="next-post pull-right"><a href="/posts/c8d1.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.guozy.online/img/2023/10/f60ceda3f75d7665ac303285a5a2bf8c.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见的Vue知识点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/4fe0ff4.html" title="TypeScript笔记(三)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img35.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-31</div><div class="title">TypeScript笔记(三)</div></div></a></div><div><a href="/posts/7a0d2fdf.html" title="TypeScript笔记(二)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-30</div><div class="title">TypeScript笔记(二)</div></div></a></div><div><a href="/posts/d044eab7.html" title="TypeScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img30.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-16</div><div class="title">TypeScript</div></div></a></div><div><a href="/posts/b5bf5235.html" title="el-input number类型右侧加减隐藏和中文光标偏移"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img39.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-20</div><div class="title">el-input number类型右侧加减隐藏和中文光标偏移</div></div></a></div><div><a href="/posts/bb44c5f1.html" title="el-input 限制输入框只能输入数字和小数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img38.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-20</div><div class="title">el-input 限制输入框只能输入数字和小数</div></div></a></div><div><a href="/posts/2201da6a.html" title="Dialog设置遮罩穿透"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img37.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-20</div><div class="title">Dialog设置遮罩穿透</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">Tom的日常</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px;"></canvas></div><script src="https://cdn.guozy.online/js/twopeople1.js"></script><script src="https://cdn.guozy.online/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.guozy.online/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center;}canvas{display:block;margin:0 auto;cursor:move;}</style></div></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-TypeScript%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD"><span class="toc-text">1.TypeScript的环境搭</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AFTypeScript"><span class="toc-text">一.什么是TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">二.环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E7%BC%96%E8%AF%91TS%E6%96%87%E4%BB%B6"><span class="toc-text">1.全局编译TS文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE-webpack-%E7%8E%AF%E5%A2%83"><span class="toc-text">2.配置 webpack 环境</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B-boolean"><span class="toc-text">布尔类型 boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B-number"><span class="toc-text">数字类型 number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-string"><span class="toc-text">字符串类型 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-array"><span class="toc-text">数组 array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B-Tuple"><span class="toc-text">元组类型 Tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enum"><span class="toc-text">3.枚举类型 enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%80%BC-any"><span class="toc-text">任意值 any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC-void"><span class="toc-text">空值 void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Null-%E5%92%8C-Undefined"><span class="toc-text">Null 和 Undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Never"><span class="toc-text">Never</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%B1%BB%E5%9E%8B"><span class="toc-text">Symbol类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInt%E7%B1%BB%E5%9E%8B"><span class="toc-text">BigInt类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">object对象类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC-type-inference"><span class="toc-text">3.类型推导(type inference)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">一. 类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-text">上下文类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-text">二.包装对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Union-Types%EF%BC%89"><span class="toc-text">三.联合类型（Union Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%EF%BC%88Discriminated-Unions%EF%BC%89"><span class="toc-text">可辨识联合（Discriminated Unions）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">四.类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">五.字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字字面量类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-vs-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">接口 vs 类型别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%8E%A8%E6%96%AD"><span class="toc-text">赋值推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A8%E6%96%AD"><span class="toc-text">返回值推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A8%E6%96%AD"><span class="toc-text">函数推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%8E%A8%E6%96%AD"><span class="toc-text">属性推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8D%E6%8E%A8"><span class="toc-text">类型反推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">索引访问操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-text">类型映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0-function"><span class="toc-text">4.函数 (function)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-text">函数的两种声明方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">为函数定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数的推断类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">可选参数和默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%8F%82%E6%95%B0"><span class="toc-text">this参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%87%8C%E7%9A%84this%E5%8F%82%E6%95%B0"><span class="toc-text">回调函数里的this参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">函数的重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%B1%BB-class"><span class="toc-text">4.类(class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-text">TS中定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">类中的修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%88%E5%85%AC%E5%BC%80%E5%B1%9E%E6%80%A7"><span class="toc-text">public  修饰符（公开属性)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E8%87%AA%E5%B7%B1%E5%92%8C%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B0"><span class="toc-text">protected修饰符 (自己和子类可以访问到)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private%E4%BF%AE%E9%A5%B0%E7%AC%A6-%EF%BC%88%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%89"><span class="toc-text">private修饰符 （私有的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6-%EF%BC%88%E4%BB%85%E8%AF%BB%EF%BC%89"><span class="toc-text">readonly修饰符 （仅读）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-text">参数属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E5%99%A8"><span class="toc-text">存取器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">静态属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Super%E5%B1%9E%E6%80%A7-%E7%BB%A7%E6%89%BF-extends"><span class="toc-text">Super属性 (继承 extends)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">类的装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E7%B1%BB"><span class="toc-text">装饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7"><span class="toc-text">装饰类中属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95"><span class="toc-text">装饰类中方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%8F%82%E6%95%B0"><span class="toc-text">装饰参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-text">高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E7%B1%BB%E5%BD%93%E5%81%9A%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8"><span class="toc-text">把类当做接口使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3-interface"><span class="toc-text">5.接口(interface)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">文档的解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly-vs-const"><span class="toc-text">readonly vs const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-text">额外的属性检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">可索引的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB-%E7%B1%BB%E5%9E%8B"><span class="toc-text">类 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">类静态部分与实例部分的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-text">继承接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">混合类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-text">接口继承类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">学习的解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0"><span class="toc-text">函数接口参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数类型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数混合类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="toc-text">对象接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7%E3%80%81%E5%8F%AF%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">任意属性、可索引接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%8E%A5%E5%8F%A3"><span class="toc-text">类接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">构造函数类型</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/87e72661.html" title="uniapp-vue2 页面生成PDF"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="uniapp-vue2 页面生成PDF"/></a><div class="content"><a class="title" href="/posts/87e72661.html" title="uniapp-vue2 页面生成PDF">uniapp-vue2 页面生成PDF</a><time datetime="2024-07-10T06:20:59.000Z" title="发表于 2024-07-10 14:20:59">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bb44c5f1.html" title="el-input 限制输入框只能输入数字和小数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img38.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="el-input 限制输入框只能输入数字和小数"/></a><div class="content"><a class="title" href="/posts/bb44c5f1.html" title="el-input 限制输入框只能输入数字和小数">el-input 限制输入框只能输入数字和小数</a><time datetime="2024-03-20T08:20:15.000Z" title="发表于 2024-03-20 16:20:15">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b5bf5235.html" title="el-input number类型右侧加减隐藏和中文光标偏移"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img39.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="el-input number类型右侧加减隐藏和中文光标偏移"/></a><div class="content"><a class="title" href="/posts/b5bf5235.html" title="el-input number类型右侧加减隐藏和中文光标偏移">el-input number类型右侧加减隐藏和中文光标偏移</a><time datetime="2024-03-20T08:16:05.000Z" title="发表于 2024-03-20 16:16:05">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2201da6a.html" title="Dialog设置遮罩穿透"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dialog设置遮罩穿透"/></a><div class="content"><a class="title" href="/posts/2201da6a.html" title="Dialog设置遮罩穿透">Dialog设置遮罩穿透</a><time datetime="2024-03-20T07:49:33.000Z" title="发表于 2024-03-20 15:49:33">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5f3c0533.html" title="常用命令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mypic-ezp.pages.dev/img/img36.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用命令"/></a><div class="content"><a class="title" href="/posts/5f3c0533.html" title="常用命令">常用命令</a><time datetime="2024-02-25T14:11:38.000Z" title="发表于 2024-02-25 22:11:38">2024-02-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Tom</div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.guozy.online/config/Aurora-%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E4%B8%AD.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://tom9527c.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/collect/"><i class="anzhiyufont anzhiyu-icon-book-open faa-tada" style="font-size: 0.9em;"></i><span> 藏宝阁</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-display"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/27/2023 22:18:52"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Tom 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/27/2023 22:18:52"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://cdn.guozy.online/config/Aurora-%E4%B8%8B%E7%8F%AD%E5%95%A6.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script async src="/custom/js/welcome.js"></script><script async src="/custom/js/vue.min.js"></script><script async src="/custom/js/elementUI.min.js"></script><script async src="/custom/js/imgStatus.min.js"></script><script async src="/custom/js/lately.min.js"></script><script async src="/custom/js/dailyPhoto.js" async></script><script async src="/custom/js/fps.js"></script><script async src="/custom/js/winBox/winbox.bundle.min.js"></script><script defer src="/custom/js/winBox/winbox.js"></script><script async src="/custom/js/aurora.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>